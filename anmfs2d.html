<!DOCTYPE html>
<html lang="es">
<head>
    <title>Proyector Anamórfico 2D Interactivo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: monospace; margin: 0; background-color: #f0f0f0;
            color: #333; overflow: hidden;
        }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; }
        #ui-container { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }
        .file-label {
            display: block; padding: 10px 15px; cursor: pointer; background-color: #0088ee;
            color: white; border-radius: 5px; font-family: monospace; text-align: center;
        }
        .file-label:hover { background-color: #0099ff; }
        input[type="file"] { display: none; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="ui-container">
        <label for="file-input" class="file-label">Cargar Imagen</label>
        <input id="file-input" type="file" accept="image/png, image/jpeg">
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        let scene, camera, renderer, controls, anamorphicPlane;
        let reflectiveCylinder, cubeCamera, sourceTexture = null;
        let gui, imageWidthController;

        const params = {
            cylinderRadius: 4.0,
            imageHeight: 10.0,
            imageWidth: 10.0,
            imageCenterY: 10.0,
            radialOffset: 0.0,
            cylinderReflectivity: 1.0,
            cylinderRoughness: 0.0,
            envMapIntensity: 1.0,
            quality: 'low',
            exportPNG: () => exportPNG(),
        };

        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            #define PI 3.14159265359

            uniform sampler2D uTexture;
            uniform bool uHasTexture;
            uniform float uCylinderRadius;
            uniform float uImageHeight;
            uniform float uImageWidth;
            uniform float uImageCenterY;
            uniform float uRadialOffset;
            uniform float uPlaneSize;
            varying vec2 vUv;

            void main() {
                vec2 centered_uv = vUv - 0.5;
                float r = length(centered_uv) * uPlaneSize;
                float theta = atan(centered_uv.y, centered_uv.x);

                if (!uHasTexture) {
                    gl_FragColor = vec4(0.9, 0.9, 0.9, 1.0);
                    return;
                }

                float theta_max = (uImageWidth / 2.0) / uCylinderRadius;
                float img_top = uImageCenterY + uImageHeight / 2.0;
                float img_bottom = uImageCenterY - uImageHeight / 2.0;

                float r_inner = (uCylinderRadius * uCylinderRadius) / img_top + uRadialOffset;
                float r_outer = (uCylinderRadius * uCylinderRadius) / img_bottom + uRadialOffset;
                
                if (r < r_inner || r > r_outer || abs(theta) > theta_max) {
                    discard;
                }

                float effective_r = r - uRadialOffset;
                if (effective_r <= 0.0) discard;

                float perceived_y = (uCylinderRadius * uCylinderRadius) / effective_r;
                float v = 1.0 - ((perceived_y - img_bottom) / uImageHeight);
                float u = (theta + theta_max) / (2.0 * theta_max);
                
                gl_FragColor = texture2D(uTexture, vec2(u, v));
            }
        `;

        function getQualitySettings(quality) {
            switch (quality) {
                case 'low':
                    return {
                        pixelRatio: 1,
                        cubeMapResolution: 512,
                        cylinderSegments: 128,
                        exportResolution: 2048
                    };
                case 'medium':
                    return {
                        pixelRatio: Math.min(window.devicePixelRatio, 2),
                        cubeMapResolution: 1024,
                        cylinderSegments: 256,
                        exportResolution: 3072
                    };
                case 'high':
                    return {
                        pixelRatio: Math.min(window.devicePixelRatio, 3),
                        cubeMapResolution: 2048,
                        cylinderSegments: 512,
                        exportResolution: 4096
                    };
                default:
                    return getQualitySettings('low');
            }
        }

        function updateQuality() {
            const settings = getQualitySettings(params.quality);
            
            // Update renderer pixel ratio
            renderer.setPixelRatio(settings.pixelRatio);
            
            // Update cylinder geometry
            if (reflectiveCylinder) {
                reflectiveCylinder.geometry.dispose();
                reflectiveCylinder.geometry = new THREE.CylinderGeometry(
                    params.cylinderRadius, 
                    params.cylinderRadius, 
                    30, 
                    settings.cylinderSegments
                );
            }
            
            // Update cube camera resolution
            if (cubeCamera) {
                const newRenderTarget = new THREE.WebGLCubeRenderTarget(settings.cubeMapResolution, {
                    format: THREE.RGBAFormat,
                    type: THREE.FloatType,
                    generateMipmaps: false,
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    wrapS: THREE.ClampToEdgeWrap,
                    wrapT: THREE.ClampToEdgeWrap,
                    anisotropy: renderer.capabilities.getMaxAnisotropy()
                });
                
                // Update cube camera
                cubeCamera.renderTarget.dispose();
                cubeCamera.renderTarget = newRenderTarget;
                
                // Update cylinder material
                if (reflectiveCylinder && reflectiveCylinder.material.uniforms) {
                    reflectiveCylinder.material.uniforms.envMap.value = newRenderTarget.texture;
                }
            }
        }

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 45, 0);

            const qualitySettings = getQualitySettings(params.quality);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: false,
                powerPreference: "high-performance",
                precision: "highp"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(qualitySettings.pixelRatio);
            renderer.toneMapping = THREE.NoToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            container.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 2.0);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 3.0);
            directionalLight1.position.set(200, 300, 200);
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 2.0);
            directionalLight2.position.set(-200, 300, -200);
            scene.add(directionalLight2);
            
            const directionalLight3 = new THREE.DirectionalLight(0xffffff, 2.0);
            directionalLight3.position.set(0, 300, 0);
            scene.add(directionalLight3);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.03;

            setupSceneObjects();
            setupGUI();

            document.getElementById('file-input').addEventListener('change', handleImageUpload);
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function setupGUI() {
            gui = new GUI({ autoPlace: false });
            document.getElementById('ui-container').appendChild(gui.domElement);

            gui.add(params, 'quality', ['low', 'medium', 'high']).name('Calidad de Renderizado').onChange(updateQuality);
            gui.add(params, 'cylinderRadius', 1.0, 10.0, 0.1).name('Radio Cilindro (cm)').onChange(updateShaderUniforms);
            imageWidthController = gui.add(params, 'imageWidth', 1.0, 40.0, 0.1).name('Ancho Virtual (cm)').onChange(updateShaderUniforms);
            gui.add(params, 'imageHeight', 1.0, 20.0, 0.1).name('Altura Virtual (cm)').onChange(updateShaderUniforms);
            gui.add(params, 'imageCenterY', 1.0, 25.0, 0.1).name('Posición Y Virtual (cm)').onChange(updateShaderUniforms);
            gui.add(params, 'radialOffset', 0.0, 20.0, 0.1).name('Offset Radial (cm)').onChange(updateShaderUniforms);
            
            const reflectionFolder = gui.addFolder('Controles de Reflectividad');
            reflectionFolder.add(params, 'cylinderReflectivity', 0.0, 1.0, 0.01)
                .name('Reflectividad')
                .onChange(updateCylinderMaterial);
            reflectionFolder.add(params, 'cylinderRoughness', 0.0, 0.3, 0.001)
                .name('Rugosidad')
                .onChange(updateCylinderMaterial);
            reflectionFolder.add(params, 'envMapIntensity', 0.5, 5.0, 0.1)
                .name('Intensidad Reflejo')
                .onChange(updateCylinderMaterial);
            
            gui.add(params, 'exportPNG').name('Exportar a PNG');
            
            reflectionFolder.open();
        }
        
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                new THREE.TextureLoader().load(e.target.result, (texture) => {
                    sourceTexture = texture;
                    
                    const aspectRatio = texture.image.width / texture.image.height;
                    params.imageWidth = params.imageHeight * aspectRatio;
                    imageWidthController.updateDisplay();
                    
                    const material = anamorphicPlane.material;
                    material.uniforms.uTexture.value = texture;
                    material.uniforms.uHasTexture.value = true;
                    updateShaderUniforms();
                });
            };
            reader.readAsDataURL(file);
        }
        
        function setupSceneObjects() {
            const gridHelper = new THREE.GridHelper(100, 100);
            scene.add(gridHelper);

            const planeSize = 80; 
            const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
            
            const shaderMaterial = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                uniforms: {
                    uTexture: { value: null },
                    uHasTexture: { value: false },
                    uCylinderRadius: { value: params.cylinderRadius },
                    uImageHeight: { value: params.imageHeight },
                    uImageWidth: { value: params.imageWidth },
                    uImageCenterY: { value: params.imageCenterY },
                    uRadialOffset: { value: params.radialOffset },
                    uPlaneSize: { value: planeSize },
                },
                transparent: true,
                side: THREE.DoubleSide,
            });

            anamorphicPlane = new THREE.Mesh(planeGeometry, shaderMaterial);
            anamorphicPlane.rotation.x = -Math.PI / 2;
            anamorphicPlane.position.y = 0.01;
            scene.add(anamorphicPlane);
            
            const qualitySettings = getQualitySettings(params.quality);
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(qualitySettings.cubeMapResolution, {
                format: THREE.RGBAFormat,
                type: THREE.FloatType,
                generateMipmaps: false,
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                wrapS: THREE.ClampToEdgeWrap,
                wrapT: THREE.ClampToEdgeWrap,
                anisotropy: renderer.capabilities.getMaxAnisotropy()
            });

            cubeCamera = new THREE.CubeCamera(0.01, 3000, cubeRenderTarget);

            const cylinderHeight = 30;
            const cylinderGeometry = new THREE.CylinderGeometry(
                params.cylinderRadius, 
                params.cylinderRadius, 
                cylinderHeight, 
                qualitySettings.cylinderSegments
            );

            const cylinderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    envMap: { value: cubeRenderTarget.texture },
                    reflectionIntensity: { value: params.envMapIntensity },
                    fresnelPower: { value: 0.0 },
                    mirrorColor: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    varying vec3 vWorldNormal;
                    varying vec3 vReflect;
                    
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        
                        vWorldNormal = normalize(normalMatrix * normal);
                        
                        vec3 worldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
                        vec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);
                        vReflect = reflect(cameraToVertex, worldNormal);
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform samplerCube envMap;
                    uniform float reflectionIntensity;
                    uniform float fresnelPower;
                    uniform vec3 mirrorColor;
                    
                    varying vec3 vWorldPosition;
                    varying vec3 vWorldNormal;
                    varying vec3 vReflect;
                    
                    void main() {
                        vec4 reflectedColor = textureCube(envMap, vReflect);
                        vec3 finalColor = reflectedColor.rgb * mirrorColor * reflectionIntensity;
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });

            reflectiveCylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            reflectiveCylinder.position.y = cylinderHeight / 2;
            reflectiveCylinder.castShadow = false;
            reflectiveCylinder.receiveShadow = false;
            reflectiveCylinder.add(cubeCamera);
            scene.add(reflectiveCylinder);

            updateCylinderMaterial();
        }

        function updateCylinderMaterial() {
            if (!reflectiveCylinder) return;
            
            const material = reflectiveCylinder.material;
            if (material.uniforms) {
                material.uniforms.reflectionIntensity.value = params.envMapIntensity;
                material.uniforms.fresnelPower.value = params.cylinderRoughness * 5.0;
                const brightness = params.cylinderReflectivity;
                material.uniforms.mirrorColor.value.setScalar(brightness);
            }
        }
        
        function updateShaderUniforms() {
            if (anamorphicPlane) {
                const material = anamorphicPlane.material;
                material.uniforms.uCylinderRadius.value = params.cylinderRadius;
                material.uniforms.uImageHeight.value = params.imageHeight;
                material.uniforms.uImageWidth.value = params.imageWidth;
                material.uniforms.uImageCenterY.value = params.imageCenterY;
                material.uniforms.uRadialOffset.value = params.radialOffset;
            }
            if (reflectiveCylinder) {
                const qualitySettings = getQualitySettings(params.quality);
                reflectiveCylinder.geometry.dispose();
                reflectiveCylinder.geometry = new THREE.CylinderGeometry(
                    params.cylinderRadius, 
                    params.cylinderRadius, 
                    30, 
                    qualitySettings.cylinderSegments
                );
            }
        }
        
        function exportPNG() {
            if (!sourceTexture) {
                alert("Por favor, carga una imagen primero.");
                return;
            }

            const qualitySettings = getQualitySettings(params.quality);
            const resolution = qualitySettings.exportResolution;
            const planeSize = 80;
            const scale = resolution / planeSize;
            const img = sourceTexture.image;
            
            const canvas = document.createElement('canvas');
            canvas.width = resolution;
            canvas.height = resolution;
            const context = canvas.getContext('2d');
            
            // Fill with transparent background initially
            context.clearRect(0, 0, resolution, resolution);
            
            // Create image data for efficient pixel manipulation
            const imageData = context.getImageData(0, 0, resolution, resolution);
            const data = imageData.data;
            
            // Create a temporary canvas to get source image pixels
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            const tempContext = tempCanvas.getContext('2d');
            tempContext.drawImage(img, 0, 0);
            const sourceData = tempContext.getImageData(0, 0, img.width, img.height).data;
            
            const img_top = params.imageCenterY + params.imageHeight / 2.0;
            const img_bottom = params.imageCenterY - params.imageHeight / 2.0;
            const theta_max = (params.imageWidth / 2.0) / params.cylinderRadius;

            let minX = resolution, maxX = 0, minY = resolution, maxY = 0;
            let hasContent = false;

            let processedRows = 0;
            const chunkSize = 10;
            
            function processChunk() {
                const endRow = Math.min(processedRows + chunkSize, resolution);
                
                for (let j = processedRows; j < endRow; j++) {
                    for (let i = 0; i < resolution; i++) {
                        const x = (i / scale) - planeSize / 2;
                        const y = (j / scale) - planeSize / 2;
                        const r = Math.sqrt(x * x + y * y);
                        const theta = Math.atan2(y, x);
                        
                        const r_inner = (params.cylinderRadius * params.cylinderRadius) / img_top + params.radialOffset;
                        const r_outer = (params.cylinderRadius * params.cylinderRadius) / img_bottom + params.radialOffset;

                        if (r >= r_inner && r <= r_outer && Math.abs(theta) <= theta_max) {
                            const effective_r = r - params.radialOffset;
                            if (effective_r > 0) {
                                const perceived_y = (params.cylinderRadius * params.cylinderRadius) / effective_r;
                                const v = (perceived_y - img_bottom) / params.imageHeight;
                                const u = (theta + theta_max) / (2.0 * theta_max);

                                if (u >= 0.0 && u <= 1.0 && v >= 0.0 && v <= 1.0) {
                                    const sx = Math.floor(u * (img.width - 1));
                                    const sy = Math.floor(v * (img.height - 1));
                                    
                                    const sourceIndex = (sy * img.width + sx) * 4;
                                    const targetIndex = (j * resolution + i) * 4;
                                    
                                    data[targetIndex] = sourceData[sourceIndex];     // R
                                    data[targetIndex + 1] = sourceData[sourceIndex + 1]; // G
                                    data[targetIndex + 2] = sourceData[sourceIndex + 2]; // B
                                    data[targetIndex + 3] = 255; // A
                                    
                                    // Track bounds for cropping
                                    minX = Math.min(minX, i);
                                    maxX = Math.max(maxX, i);
                                    minY = Math.min(minY, j);
                                    maxY = Math.max(maxY, j);
                                    hasContent = true;
                                }
                            }
                        }
                    }
                }
                
                processedRows = endRow;
                
                if (processedRows < resolution) {
                    // Continue processing in the next frame
                    requestAnimationFrame(processChunk);
                } else {
                    // Finished processing, now crop and download
                    context.putImageData(imageData, 0, 0);
                    
                    if (hasContent) {
                        // Add small padding around the content
                        const padding = Math.max(10, Math.floor(resolution * 0.01));
                        minX = Math.max(0, minX - padding);
                        maxX = Math.min(resolution - 1, maxX + padding);
                        minY = Math.max(0, minY - padding);
                        maxY = Math.min(resolution - 1, maxY + padding);
                        
                        const cropWidth = maxX - minX + 1;
                        const cropHeight = maxY - minY + 1;
                        
                        // Create cropped canvas
                        const croppedCanvas = document.createElement('canvas');
                        croppedCanvas.width = cropWidth;
                        croppedCanvas.height = cropHeight;
                        const croppedContext = croppedCanvas.getContext('2d');
                        
                        // Fill with white background
                        croppedContext.fillStyle = "white";
                        croppedContext.fillRect(0, 0, cropWidth, cropHeight);
                        
                        // Copy cropped area
                        croppedContext.drawImage(
                            canvas,
                            minX, minY, cropWidth, cropHeight,
                            0, 0, cropWidth, cropHeight
                        );
                        
                        // Download cropped version
                        const link = document.createElement('a');
                        link.download = 'anamorfosis_cropped.png';
                        link.href = croppedCanvas.toDataURL('image/png');
                        link.click();
                    } else {
                        alert("No se encontró contenido para exportar.");
                    }
                }
            }
            
            processChunk();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if (cubeCamera && reflectiveCylinder) {
                reflectiveCylinder.visible = false;
                const oldPixelRatio = renderer.getPixelRatio();
                renderer.setPixelRatio(2.0);
                cubeCamera.update(renderer, scene);
                renderer.setPixelRatio(oldPixelRatio);
                reflectiveCylinder.visible = true;
            }
            
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
