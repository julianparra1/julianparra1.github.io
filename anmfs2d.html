<!DOCTYPE html>
<html lang="es">
<head>
    <title>Proyector Anamórfico 2D Interactivo</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: monospace; margin: 0; background-color: #f0f0f0;
            color: #333; overflow: hidden;
        }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; }
        #ui-container { position: absolute; top: 10px; left: 10px; z-index: 100; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }
        .file-label {
            display: block; padding: 10px 15px; cursor: pointer; background-color: #0088ee;
            color: white; border-radius: 5px; font-family: monospace; text-align: center;
        }
        .file-label:hover { background-color: #0099ff; }
        input[type="file"] { display: none; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="ui-container">
        <label for="file-input" class="file-label">Cargar Imagen</label>
        <input id="file-input" type="file" accept="image/png, image/jpeg">
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        let scene, camera, renderer, controls, anamorphicPlane;
        let reflectiveCylinder, cubeCamera, sourceTexture = null;
        let gui, imageWidthController;

        const params = {
            cylinderRadius: 4.0,
            imageHeight: 10.0,
            imageWidth: 10.0,
            imageCenterY: 10.0,
            radialOffset: 0.0,
            cylinderReflectivity: 1.0,
            cylinderRoughness: 0.0,
            envMapIntensity: 1.0,
            quality: 'low',
            exportPNG: () => exportPNG(),
        };

        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            #define PI 3.14159265359

            uniform sampler2D uTexture;
            uniform bool uHasTexture;
            uniform float uCylinderRadius;
            uniform float uImageHeight;
            uniform float uImageWidth;
            uniform float uImageCenterY;
            uniform float uRadialOffset;
            uniform float uPlaneSize;
            varying vec2 vUv;

            void main() {
                vec2 centered_uv = vUv - 0.5;
                float r = length(centered_uv) * uPlaneSize;
                float theta = atan(centered_uv.y, centered_uv.x);

                if (!uHasTexture) {
                    gl_FragColor = vec4(0.9, 0.9, 0.9, 1.0);
                    return;
                }

                float theta_max = (uImageWidth / 2.0) / uCylinderRadius;
                float img_top = uImageCenterY + uImageHeight / 2.0;
                float img_bottom = uImageCenterY - uImageHeight / 2.0;

                float r_inner = (uCylinderRadius * uCylinderRadius) / img_top + uRadialOffset;
                float r_outer = (uCylinderRadius * uCylinderRadius) / img_bottom + uRadialOffset;
                
                if (r < r_inner || r > r_outer || abs(theta) > theta_max) {
                    discard;
                }

                float effective_r = r - uRadialOffset;
                if (effective_r <= 0.0) discard;

                float perceived_y = (uCylinderRadius * uCylinderRadius) / effective_r;
                float v = 1.0 - ((perceived_y - img_bottom) / uImageHeight);
                float u = (theta + theta_max) / (2.0 * theta_max);
                
                gl_FragColor = texture2D(uTexture, vec2(u, v));
            }
        `;

        function getQualitySettings(quality) {
            switch (quality) {
                case 'low':
                    return {
                        pixelRatio: 1,
                        cubeMapResolution: 512,
                        cylinderSegments: 128,
                        exportResolution: 2048
                    };
                case 'medium':
                    return {
                        pixelRatio: Math.min(window.devicePixelRatio, 2),
                        cubeMapResolution: 1024,
                        cylinderSegments: 256,
                        exportResolution: 3072
                    };
                case 'high':
                    return {
                        pixelRatio: Math.min(window.devicePixelRatio, 3),
                        cubeMapResolution: 2048,
                        cylinderSegments: 512,
                        exportResolution: 4096
                    };
                default:
                    return getQualitySettings('low');
            }
        }

        function updateQuality() {
            const settings = getQualitySettings(params.quality);
            
            // Update renderer pixel ratio
            renderer.setPixelRatio(settings.pixelRatio);
            
            // Update cylinder geometry
            if (reflectiveCylinder) {
                reflectiveCylinder.geometry.dispose();
                reflectiveCylinder.geometry = new THREE.CylinderGeometry(
                    params.cylinderRadius, 
                    params.cylinderRadius, 
                    30, 
                    settings.cylinderSegments
                );
            }
            
            // Update cube camera resolution
            if (cubeCamera) {
                const newRenderTarget = new THREE.WebGLCubeRenderTarget(settings.cubeMapResolution, {
                    format: THREE.RGBAFormat,
                    type: THREE.FloatType,
                    generateMipmaps: false,
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    wrapS: THREE.ClampToEdgeWrap,
                    wrapT: THREE.ClampToEdgeWrap,
                    anisotropy: renderer.capabilities.getMaxAnisotropy()
                });
                
                // Update cube camera
                cubeCamera.renderTarget.dispose();
                cubeCamera.renderTarget = newRenderTarget;
                
                // Update cylinder material
                if (reflectiveCylinder && reflectiveCylinder.material.uniforms) {
                    reflectiveCylinder.material.uniforms.envMap.value = newRenderTarget.texture;
                }
            }
        }

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 45, 0);

            const qualitySettings = getQualitySettings(params.quality);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: false,
                powerPreference: "high-performance",
                precision: "highp"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(qualitySettings.pixelRatio);
            renderer.toneMapping = THREE.NoToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            container.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 2.0);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 3.0);
            directionalLight1.position.set(200, 300, 200);
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 2.0);
            directionalLight2.position.set(-200, 300, -200);
            scene.add(directionalLight2);
            
            const directionalLight3 = new THREE.DirectionalLight(0xffffff, 2.0);
            directionalLight3.position.set(0, 300, 0);
            scene.add(directionalLight3);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.03;

            setupSceneObjects();
            setupGUI();

            document.getElementById('file-input').addEventListener('change', handleImageUpload);
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function setupGUI() {
            gui = new GUI({ autoPlace: false });
            document.getElementById('ui-container').appendChild(gui.domElement);

            gui.add(params, 'quality', ['low', 'medium', 'high']).name('Calidad de Renderizado').onChange(updateQuality);
            gui.add(params, 'cylinderRadius', 1.0, 10.0, 0.1).name('Radio Cilindro (cm)').onChange(updateShaderUniforms);
            imageWidthController = gui.add(params, 'imageWidth', 1.0, 40.0, 0.1).name('Ancho Virtual (cm)').onChange(updateShaderUniforms);
            gui.add(params, 'imageHeight', 1.0, 20.0, 0.1).name('Altura Virtual (cm)').onChange(updateShaderUniforms);
            gui.add(params, 'imageCenterY', 1.0, 25.0, 0.1).name('Posición Y Virtual (cm)').onChange(updateShaderUniforms);
            gui.add(params, 'radialOffset', 0.0, 20.0, 0.1).name('Offset Radial (cm)').onChange(updateShaderUniforms);
            
            const reflectionFolder = gui.addFolder('Controles de Reflectividad');
            reflectionFolder.add(params, 'cylinderReflectivity', 0.0, 1.0, 0.01)
                .name('Reflectividad')
                .onChange(updateCylinderMaterial);
            reflectionFolder.add(params, 'cylinderRoughness', 0.0, 0.3, 0.001)
                .name('Rugosidad')
                .onChange(updateCylinderMaterial);
            reflectionFolder.add(params, 'envMapIntensity', 0.5, 5.0, 0.1)
                .name('Intensidad Reflejo')
                .onChange(updateCylinderMaterial);
            
            gui.add(params, 'exportPNG').name('Exportar a PNG');
            
            reflectionFolder.open();
        }
        
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                new THREE.TextureLoader().load(e.target.result, (texture) => {
                    sourceTexture = texture;
                    
                    const aspectRatio = texture.image.width / texture.image.height;
                    params.imageWidth = params.imageHeight * aspectRatio;
                    imageWidthController.updateDisplay();
                    
                    const material = anamorphicPlane.material;
                    material.uniforms.uTexture.value = texture;
                    material.uniforms.uHasTexture.value = true;
                    updateShaderUniforms();
                });
            };
            reader.readAsDataURL(file);
        }
        
        function setupSceneObjects() {
            const gridHelper = new THREE.GridHelper(100, 100);
            scene.add(gridHelper);

            const planeSize = 80; 
            const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
            
            const shaderMaterial = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                uniforms: {
                    uTexture: { value: null },
                    uHasTexture: { value: false },
                    uCylinderRadius: { value: params.cylinderRadius },
                    uImageHeight: { value: params.imageHeight },
                    uImageWidth: { value: params.imageWidth },
                    uImageCenterY: { value: params.imageCenterY },
                    uRadialOffset: { value: params.radialOffset },
                    uPlaneSize: { value: planeSize },
                },
                transparent: true,
                side: THREE.DoubleSide,
            });

            anamorphicPlane = new THREE.Mesh(planeGeometry, shaderMaterial);
            anamorphicPlane.rotation.x = -Math.PI / 2;
            anamorphicPlane.position.y = 0.01;
            scene.add(anamorphicPlane);
            
            const qualitySettings = getQualitySettings(params.quality);
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(qualitySettings.cubeMapResolution, {
                format: THREE.RGBAFormat,
                type: THREE.FloatType,
                generateMipmaps: false,
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                wrapS: THREE.ClampToEdgeWrap,
                wrapT: THREE.ClampToEdgeWrap,
                anisotropy: renderer.capabilities.getMaxAnisotropy()
            });

            cubeCamera = new THREE.CubeCamera(0.01, 3000, cubeRenderTarget);

            const cylinderHeight = 30;
            const cylinderGeometry = new THREE.CylinderGeometry(
                params.cylinderRadius, 
                params.cylinderRadius, 
                cylinderHeight, 
                qualitySettings.cylinderSegments
            );

            const cylinderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    envMap: { value: cubeRenderTarget.texture },
                    reflectionIntensity: { value: params.envMapIntensity },
                    fresnelPower: { value: 0.0 },
                    mirrorColor: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    varying vec3 vWorldNormal;
                    varying vec3 vReflect;
                    
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        
                        vWorldNormal = normalize(normalMatrix * normal);
                        
                        vec3 worldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
                        vec3 cameraToVertex = normalize(vWorldPosition - cameraPosition);
                        vReflect = reflect(cameraToVertex, worldNormal);
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform samplerCube envMap;
                    uniform float reflectionIntensity;
                    uniform float fresnelPower;
                    uniform vec3 mirrorColor;
                    
                    varying vec3 vWorldPosition;
                    varying vec3 vWorldNormal;
                    varying vec3 vReflect;
                    
                    void main() {
                        vec4 reflectedColor = textureCube(envMap, vReflect);
                        vec3 finalColor = reflectedColor.rgb * mirrorColor * reflectionIntensity;
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });

            reflectiveCylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            reflectiveCylinder.position.y = cylinderHeight / 2;
            reflectiveCylinder.castShadow = false;
            reflectiveCylinder.receiveShadow = false;
            reflectiveCylinder.add(cubeCamera);
            scene.add(reflectiveCylinder);

            updateCylinderMaterial();
        }

        function updateCylinderMaterial() {
            if (!reflectiveCylinder) return;
            
            const material = reflectiveCylinder.material;
            if (material.uniforms) {
                material.uniforms.reflectionIntensity.value = params.envMapIntensity;
                material.uniforms.fresnelPower.value = params.cylinderRoughness * 5.0;
                const brightness = params.cylinderReflectivity;
                material.uniforms.mirrorColor.value.setScalar(brightness);
            }
        }
        
        function updateShaderUniforms() {
            if (anamorphicPlane) {
                const material = anamorphicPlane.material;
                material.uniforms.uCylinderRadius.value = params.cylinderRadius;
                material.uniforms.uImageHeight.value = params.imageHeight;
                material.uniforms.uImageWidth.value = params.imageWidth;
                material.uniforms.uImageCenterY.value = params.imageCenterY;
                material.uniforms.uRadialOffset.value = params.radialOffset;
            }
            if (reflectiveCylinder) {
                const qualitySettings = getQualitySettings(params.quality);
                reflectiveCylinder.geometry.dispose();
                reflectiveCylinder.geometry = new THREE.CylinderGeometry(
                    params.cylinderRadius, 
                    params.cylinderRadius, 
                    30, 
                    qualitySettings.cylinderSegments
                );
            }
        }
        
        function exportPNG() {
            if (!sourceTexture) {
                alert("Por favor, carga una imagen primero.");
                return;
            }

            const qualitySettings = getQualitySettings(params.quality);
            const resolution = qualitySettings.exportResolution;
            const planeSize = 80;
            const scale = resolution / planeSize;
            const img = sourceTexture.image;
            
            const canvas = document.createElement('canvas');
            canvas.width = resolution;
            canvas.height = resolution;
            const context = canvas.getContext('2d');
            
            context.fillStyle = "white";
            context.fillRect(0, 0, resolution, resolution);
            
            const img_top = params.imageCenterY + params.imageHeight / 2.0;
            const img_bottom = params.imageCenterY - params.imageHeight / 2.0;
            const theta_max = (params.imageWidth / 2.0) / params.cylinderRadius;

            for (let j = 0; j < resolution; j++) {
                for (let i = 0; i < resolution; i++) {
                    const x = (i / scale) - planeSize / 2;
                    const y = (j / scale) - planeSize / 2;
                    const r = Math.sqrt(x * x + y * y);
                    const theta = Math.atan2(y, x);
                    
                    const r_inner = (params.cylinderRadius * params.cylinderRadius) / img_top + params.radialOffset;
                    const r_outer = (params.cylinderRadius * params.cylinderRadius) / img_bottom + params.radialOffset;

                    if (r < r_inner || r > r_outer || Math.abs(theta) > theta_max) continue;

                    const effective_r = r - params.radialOffset;
                    if (effective_r <= 0) continue;
                    
                    const perceived_y = (params.cylinderRadius * params.cylinderRadius) / effective_r;
                    const v = (perceived_y - img_bottom) / params.imageHeight;
                    const u = (theta + theta_max) / (2.0 * theta_max);

                    if (u >= 0.0 && u <= 1.0 && v >= 0.0 && v <= 1.0) {
                        const sx = u * img.width;
                        const sy = (1.0-v) * img.height;
                        context.drawImage(img, sx, sy, 1, 1, i, j, 1, 1);
                    }
                }
            }
            
            const link = document.createElement('a');
            link.download = 'anamorfosis.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if (cubeCamera && reflectiveCylinder) {
                reflectiveCylinder.visible = false;
                const oldPixelRatio = renderer.getPixelRatio();
                renderer.setPixelRatio(2.0);
                cubeCamera.update(renderer, scene);
                renderer.setPixelRatio(oldPixelRatio);
                reflectiveCylinder.visible = true;
            }
            
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
