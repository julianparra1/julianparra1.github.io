<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Estudio de Teselados</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --bg-color: #080808;
            --panel-bg: rgba(20, 20, 20, 0.85);
            --border-color: rgba(255, 255, 255, 0.08);
            --text-main: #e0e0e0;
            --text-muted: #888;
            --accent: #fff;
            --highlight: #3b82f6;
            --guide-color: rgba(255, 255, 255, 0.15);
            --region-color: rgba(59, 130, 246, 0.1);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; outline: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .main-layout {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        /* --- Sidebar --- */
        .sidebar {
            width: 340px;
            background: var(--panel-bg);
            backdrop-filter: blur(20px);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            z-index: 20;
            transition: transform 0.3s ease;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }

        .sidebar-header h1 {
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        .scroll-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            -webkit-overflow-scrolling: touch; 
            touch-action: pan-y; /* Explicitly allow vertical scrolling */
        }
        
        .scroll-area::-webkit-scrollbar { width: 4px; }
        .scroll-area::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

        .section-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 12px;
            display: block;
            margin-top: 24px;
            font-weight: 600;
        }
        .section-label:first-child { margin-top: 0; }

        .group-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        button.group-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            padding: 12px 0;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 6px;
            font-size: 12px;
        }

        button.group-btn:hover {
            border-color: rgba(255,255,255,0.3);
            color: #fff;
            background: rgba(255,255,255,0.02);
        }

        button.group-btn.active {
            background: #fff;
            color: #000;
            border-color: #fff;
            font-weight: 600;
        }

        /* --- Controls --- */
        .controls-footer {
            padding: 20px;
            border-top: 1px solid var(--border-color);
            background: rgba(0,0,0,0.2);
            flex-shrink: 0;
            touch-action: pan-y;
        }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            gap: 12px;
            transition: opacity 0.2s;
        }

        .control-label {
            font-size: 11px;
            color: #888;
            min-width: 60px;
        }
        
        .control-val {
            font-size: 10px;
            color: #555;
            width: 30px;
            text-align: right;
            font-feature-settings: "tnum";
        }

        input[type="range"] {
            -webkit-appearance: none;
            flex-grow: 1;
            height: 4px; 
            background: #333;
            outline: none;
            border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px; height: 18px; 
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            border: 2px solid #111;
        }
        
        .control-row.hidden { display: none !important; }

        input[type="color"] {
            -webkit-appearance: none;
            border: 1px solid var(--border-color);
            width: 100%; height: 36px;
            padding: 0;
            background: none;
            cursor: pointer;
            border-radius: 6px;
        }

        .toggle-switch {
            position: relative;
            width: 40px; height: 24px;
            background: #333;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .toggle-switch.active { background: #fff; }
        .toggle-knob {
            position: absolute;
            top: 2px; left: 2px;
            width: 20px; height: 20px;
            background: #000;
            border-radius: 50%;
            transition: transform 0.2s;
        }
        .toggle-switch.active .toggle-knob { transform: translateX(16px); }

        .btn-row { display: flex; gap: 8px; margin-top: 10px; }
        .action-btn {
            flex: 1;
            padding: 14px;
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--border-color);
            color: #fff;
            font-size: 11px;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 6px;
            font-weight: 500;
            text-align: center;
        }
        .action-btn:hover { background: rgba(255,255,255,0.1); }

        /* --- Canvas & Tools --- */
        .canvas-container {
            flex-grow: 1;
            position: relative;
            cursor: crosshair;
            overflow: hidden;
            background: #050505;
            background-image: radial-gradient(rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 20px 20px;
            touch-action: none; /* Prevents scrolling on canvas only */
        }

        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; touch-action: none; }
        #gridCanvas { z-index: 5; pointer-events: none; }
        #drawCanvas { z-index: 10; pointer-events: none; } 
        #previewCanvas { z-index: 15; } 

        .toolbar {
            position: absolute;
            top: 20px; right: 20px;
            background: var(--panel-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            padding: 6px;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 50;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .tool-btn {
            width: 44px; height: 44px; /* Larger touch target */
            display: flex; align-items: center; justify-content: center;
            border-radius: 8px;
            color: #888;
            cursor: pointer;
            transition: all 0.2s;
        }
        .tool-btn:hover { color: #fff; background: rgba(255,255,255,0.05); }
        .tool-btn.active { color: #000; background: #fff; }
        .tool-btn svg { width: 20px; height: 20px; }

        .status-bar {
            position: absolute;
            bottom: 20px; right: 20px;
            text-align: right;
            pointer-events: none;
            z-index: 20;
        }
        .status-item { 
            display: flex; align-items: center; justify-content: flex-end;
            gap: 12px; margin-top: 6px;
            font-size: 10px; letter-spacing: 0.05em;
            color: rgba(255,255,255,0.4); 
            text-transform: uppercase;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        .legend-mark { width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; border: 1px solid rgba(255,255,255,0.1); background: rgba(0,0,0,0.5); }
        .l-mirror { width: 100%; height: 1px; background: #fff; }
        .l-glide { width: 100%; height: 1px; border-bottom: 1px dashed #fff; }
        
        .s-diamond { width: 6px; height: 6px; background: #fff; transform: rotate(45deg); }
        .s-triangle { width: 0; height: 0; border-left: 4px solid transparent; border-right: 4px solid transparent; border-bottom: 7px solid #fff; }
        .s-square { width: 6px; height: 6px; background: #fff; }
        .s-hex { width: 8px; height: 8px; background: #fff; clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%); }

        /* --- Mobile Responsive Fix --- */
        @media (max-width: 900px) {
            .main-layout { flex-direction: column; }
            .sidebar {
                width: 100%; height: 45vh; order: 2;
                border-right: none; border-top: 1px solid var(--border-color);
                display: block; overflow-y: auto; -webkit-overflow-scrolling: touch;
                touch-action: pan-y; /* Ensure vertical scroll is allowed */
            }
            .sidebar-header { position: sticky; top: 0; z-index: 30; border-bottom: 1px solid var(--border-color); }
            .scroll-area { flex: none; overflow: visible; height: auto; padding-bottom: 0; }
            .controls-footer { flex: none; border-top: none; padding-top: 0; }
            .canvas-container { width: 100%; height: 55vh; order: 1; }
            .toolbar { top: auto; bottom: 20px; left: 20px; right: auto; flex-direction: row; }
            .status-bar { top: 20px; bottom: auto; }
            .sidebar-header { padding: 12px; }
            .scroll-area { padding: 15px; }
            .controls-footer { padding: 5px 15px 30px 15px; }
        }

    </style>
</head>
<body>

    <div class="main-layout">
        
        <div class="sidebar">
            <div class="sidebar-header">
                <h1>Estudio de Teselados</h1>
            </div>

            <div class="scroll-area">
                
                <span class="section-label">Básicos</span>
                <div class="group-grid">
                    <button class="group-btn" onclick="app.setGroup('p1')">p1</button>
                    <button class="group-btn" onclick="app.setGroup('pm')">pm</button>
                    <button class="group-btn" onclick="app.setGroup('pg')">pg</button>
                    <button class="group-btn" onclick="app.setGroup('cm')">cm</button>
                </div>

                <span class="section-label">Rotación 180°</span>
                <div class="group-grid" style="grid-template-columns: repeat(3, 1fr);">
                    <button class="group-btn" onclick="app.setGroup('p2')">p2</button>
                    <button class="group-btn" onclick="app.setGroup('pmm')">pmm</button>
                    <button class="group-btn" onclick="app.setGroup('pmg')">pmg</button>
                    <button class="group-btn" onclick="app.setGroup('pgg')">pgg</button>
                    <button class="group-btn" onclick="app.setGroup('cmm')">cmm</button>
                </div>

                <span class="section-label">Cuadrado (90°)</span>
                <div class="group-grid" style="grid-template-columns: repeat(3, 1fr);">
                    <button class="group-btn" onclick="app.setGroup('p4')">p4</button>
                    <button class="group-btn active" onclick="app.setGroup('p4m')">p4m</button>
                    <button class="group-btn" onclick="app.setGroup('p4g')">p4g</button>
                </div>

                <span class="section-label">Hexagonal (60°)</span>
                <div class="group-grid" style="grid-template-columns: repeat(3, 1fr);">
                    <button class="group-btn" onclick="app.setGroup('p3')">p3</button>
                    <button class="group-btn" onclick="app.setGroup('p3m1')">p3m1</button>
                    <button class="group-btn" onclick="app.setGroup('p31m')">p31m</button>
                    <button class="group-btn" onclick="app.setGroup('p6')">p6</button>
                    <button class="group-btn" onclick="app.setGroup('p6m')">p6m</button>
                </div>

            </div>

            <div class="controls-footer">
                
                <div class="control-row">
                    <span class="control-label">Guías</span>
                    <div class="toggle-switch active" id="guideToggle" onclick="app.toggleGuides()">
                        <div class="toggle-knob"></div>
                    </div>
                </div>

                <div class="control-row">
                    <span class="control-label">Suavizado</span>
                    <div class="toggle-switch" id="smoothToggle" onclick="app.toggleSmoothing()">
                        <div class="toggle-knob"></div>
                    </div>
                </div>

                <div class="control-row hidden" id="row-smooth-level">
                    <span class="control-label">Nivel</span>
                    <input type="range" min="1" max="10" value="3" id="smoothSlider" disabled oninput="app.updateParams()">
                    <span class="control-val" id="val-smooth">3</span>
                </div>

                <div class="control-row hidden" id="row-glide">
                    <span class="control-label">Deslizamiento</span>
                    <input type="range" min="0" max="100" value="50" id="glideSlider" oninput="app.updateParams()">
                    <span class="control-val" id="val-glide">0.5</span>
                </div>

                <div class="control-row">
                    <span class="control-label">Escala</span>
                    <input type="range" min="70" max="400" value="160" id="scaleSlider" oninput="app.updateParams()">
                </div>

                <div class="control-row hidden" id="row-ratio">
                    <span class="control-label">Proporción</span>
                    <input type="range" min="50" max="200" value="100" id="ratioSlider" oninput="app.updateParams()">
                    <span class="control-val" id="val-ratio">1.0</span>
                </div>

                <div class="control-row hidden" id="row-angle">
                    <span class="control-label">Ángulo</span>
                    <input type="range" min="30" max="150" value="90" id="angleSlider" oninput="app.updateParams()">
                    <span class="control-val" id="val-angle">90°</span>
                </div>

                <div class="control-row">
                    <span class="control-label">Grosor</span>
                    <input type="range" min="1" max="40" value="4" id="strokeSlider" oninput="app.lineWidth = this.value">
                </div>

                <div class="control-row">
                    <input type="color" value="#ffffff" id="colorPicker" oninput="app.color = this.value">
                </div>
                
                <div class="btn-row">
                    <button class="action-btn" onclick="app.undo()">Deshacer</button>
                    <button class="action-btn" onclick="app.clear()">Limpiar</button>
                </div>
                <div class="btn-row">
                    <button class="action-btn" onclick="app.download()">Guardar Imagen</button>
                    <button class="action-btn" onclick="app.downloadTile()">Guardar Azulejo</button>
                </div>

            </div>
        </div>

        <div class="canvas-container" id="container">
            <canvas id="gridCanvas"></canvas>
            <canvas id="drawCanvas"></canvas>
            <canvas id="previewCanvas"></canvas>
            
            <div class="toolbar">
                <div class="tool-btn active" id="tool-pen" onclick="app.setTool('pen')" title="Mano alzada">
                    <i data-lucide="pencil"></i>
                </div>
                <div class="tool-btn" id="tool-line" onclick="app.setTool('line')" title="Línea">
                    <i data-lucide="minus"></i>
                </div>
                <div class="tool-btn" id="tool-rect" onclick="app.setTool('rect')" title="Rectángulo">
                    <i data-lucide="square"></i>
                </div>
                <div class="tool-btn" id="tool-circle" onclick="app.setTool('circle')" title="Círculo">
                    <i data-lucide="circle"></i>
                </div>
            </div>

            <div class="status-bar" id="legend">
                <div style="font-weight:600; color:#fff; margin-bottom:10px; letter-spacing:0.1em; font-size:11px;">LEYENDA</div>
                <div class="status-item">Región <div class="legend-mark" style="background: rgba(59,130,246,0.2)"></div></div>
                <div class="status-item">Espejo <div class="legend-mark"><div class="l-mirror"></div></div></div>
                <div class="status-item">Deslizamiento <div class="legend-mark"><div class="l-glide"></div></div></div>
                <div class="status-item">Rotación 2 <div class="legend-mark"><div class="s-diamond"></div></div></div>
                <div class="status-item">Rotación 3 <div class="legend-mark"><div class="s-triangle"></div></div></div>
                <div class="status-item">Rotación 4 <div class="legend-mark"><div class="s-square"></div></div></div>
                <div class="status-item">Rotación 6 <div class="legend-mark"><div class="s-hex"></div></div></div>
            </div>
        </div>

    </div>

<script>
class WallpaperApp {
    constructor() {
        this.mainCanvas = document.getElementById('drawCanvas');
        this.gridCanvas = document.getElementById('gridCanvas');
        this.prevCanvas = document.getElementById('previewCanvas');
        this.container = document.getElementById('container');
        
        this.ctx = this.mainCanvas.getContext('2d');
        this.gCtx = this.gridCanvas.getContext('2d');
        this.pCtx = this.prevCanvas.getContext('2d');

        this.group = 'p4m';
        this.tool = 'pen';
        this.color = '#ffffff';
        this.lineWidth = 4;
        this.showGuides = true;
        this.smoothingEnabled = false;
        this.smoothingLevel = 3;
        
        this.scale = 160;
        this.angle = 90;
        this.ratio = 1.0;
        this.glide = 0.5;
        
        this.drawings = [];
        this.currentPath = []; 
        
        this.isDrawing = false;
        this.startPos = {x:0, y:0};
        this.lastPos = {x:0, y:0};
        this.history = []; 
        this.historyStep = -1;

        this.cachedTransforms = [];
        this.viewBounds = { uMin:0, uMax:0, vMin:0, vMax:0, rangeU:0, rangeV:0 };

        this.init();
    }

    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.bindEvents();
        this.updateParams();
        lucide.createIcons();
        this.saveState();
        
        document.addEventListener('keydown', (e) => {
            if((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); this.undo(); }
        });
    }

    bindEvents() {
        const getPos = (e) => {
            const rect = this.prevCanvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
        };

        const start = (e) => {
            // If multi-touch (zoom/pan), don't draw
            if(e.touches && e.touches.length > 1) return; 
            
            this.isDrawing = true;
            const pos = getPos(e);
            this.startPos = pos;
            this.lastPos = pos;
            
            const uv = this.getLatticeTransform(pos.x, pos.y);
            
            if (this.tool === 'pen') {
                this.currentPath = [uv];
                this.drawDot(pos); 
            }
        };

        const move = (e) => {
            if (!this.isDrawing) return; // If not drawing, let default events happen (scrolling)
            
            if(e.touches) {
                if (e.touches.length > 1) return; 
                e.preventDefault(); // Only prevent scrolling if drawing
            }
            
            const pos = getPos(e);
            
            if (this.tool === 'pen') {
                this.ctx.strokeStyle = this.color;
                this.ctx.lineWidth = this.lineWidth;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                this.drawSymmetrySegment(this.lastPos, pos, this.ctx);
                
                const uv = this.getLatticeTransform(pos.x, pos.y);
                this.currentPath.push(uv);
                
                this.lastPos = pos;
            } else {
                this.pCtx.clearRect(0,0,this.width, this.height);
                this.drawShapePreview(this.startPos, pos);
                this.lastPos = pos;
            }
        };

        const end = (e) => {
            if(!this.isDrawing) return;
            this.isDrawing = false;
            
            const startUV = this.getLatticeTransform(this.startPos.x, this.startPos.y);
            const endUV = this.getLatticeTransform(this.lastPos.x, this.lastPos.y);

            if (this.tool === 'pen') {
                let points = this.currentPath;
                if(this.smoothingEnabled) {
                    for(let i=0; i<this.smoothingLevel; i++) {
                        points = this.smoothPath(points);
                    }
                }
                this.drawings.push({
                    type: 'pen',
                    points: points,
                    color: this.color,
                    width: this.lineWidth
                });
                this.redrawAll();
            } else {
                this.pCtx.clearRect(0,0,this.width, this.height);
                this.drawShape(this.startPos, this.lastPos, this.ctx);
                this.drawings.push({
                    type: this.tool,
                    p1: startUV,
                    p2: endUV,
                    color: this.color,
                    width: this.lineWidth
                });
            }
            this.saveState();
        };

        const c = this.prevCanvas; 
        c.addEventListener('mousedown', start);
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end);
        c.addEventListener('touchstart', start, {passive:false});
        window.addEventListener('touchmove', move, {passive:false});
        window.addEventListener('touchend', end);
    }

    resize() {
        const parent = this.container;
        this.width = parent.clientWidth;
        this.height = parent.clientHeight;
        [this.mainCanvas, this.gridCanvas, this.prevCanvas].forEach(c => {
            c.width = this.width; c.height = this.height;
        });
        this.updateViewBounds();
        this.redrawAll();
        this.drawGuides();
    }

    setGroup(id) {
        this.group = id;
        document.querySelectorAll('.group-btn').forEach(b => b.classList.remove('active'));
        document.querySelector(`button[onclick="app.setGroup('${id}')"]`).classList.add('active');
        this.updateParams();
        this.redrawAll();
    }

    setTool(t) {
        this.tool = t;
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`tool-${t}`).classList.add('active');
    }

    toggleGuides() {
        this.showGuides = !this.showGuides;
        document.getElementById('guideToggle').classList.toggle('active', this.showGuides);
        if(this.showGuides) document.getElementById('legend').style.display = 'block';
        else document.getElementById('legend').style.display = 'none';
        this.drawGuides();
    }

    toggleSmoothing() {
        this.smoothingEnabled = !this.smoothingEnabled;
        document.getElementById('smoothToggle').classList.toggle('active', this.smoothingEnabled);
        
        const levelRow = document.getElementById('row-smooth-level');
        const levelInput = document.getElementById('smoothSlider');
        
        if(this.smoothingEnabled) {
            levelRow.classList.remove('hidden');
            levelInput.disabled = false;
        } else {
            levelRow.classList.add('hidden');
            levelInput.disabled = true;
        }
    }

    smoothPath(points) {
        if (points.length < 3) return points;
        const smoothed = [];
        smoothed.push(points[0]); 
        for (let i = 1; i < points.length - 1; i++) {
            const p0 = points[i - 1]; const p1 = points[i]; const p2 = points[i + 1];
            const u = (p0.u + 2 * p1.u + p2.u) / 4; const v = (p0.v + 2 * p1.v + p2.v) / 4;
            smoothed.push({ u, v });
        }
        smoothed.push(points[points.length - 1]); 
        return smoothed;
    }

    updateParams() {
        this.scale = parseInt(document.getElementById('scaleSlider').value);
        this.ratio = parseInt(document.getElementById('ratioSlider').value) / 100;
        this.angle = parseInt(document.getElementById('angleSlider').value);
        this.glide = parseInt(document.getElementById('glideSlider').value) / 100;
        this.smoothingLevel = parseInt(document.getElementById('smoothSlider').value);
        
        const ratioRow = document.getElementById('row-ratio');
        const angleRow = document.getElementById('row-angle');
        const glideRow = document.getElementById('row-glide');
        const rInput = document.getElementById('ratioSlider');
        const aInput = document.getElementById('angleSlider');
        const gInput = document.getElementById('glideSlider');

        document.getElementById('val-ratio').innerText = this.ratio.toFixed(2);
        document.getElementById('val-angle').innerText = this.angle + '°';
        document.getElementById('val-glide').innerText = this.glide.toFixed(2);
        document.getElementById('val-smooth').innerText = this.smoothingLevel;

        let lockRatio = false; let lockAngle = false; let enableGlide = false;
        const hexGroups = ['p3', 'p3m1', 'p31m', 'p6', 'p6m'];
        const squareGroups = ['p4', 'p4m', 'p4g'];
        const rectGroups = ['pm', 'pg', 'cm', 'pmm', 'pmg', 'pgg', 'cmm'];
        const glideGroups = ['pg', 'pmg', 'pgg', 'p4g'];

        if (hexGroups.includes(this.group)) { lockRatio = true; this.ratio = 1.0; lockAngle = true; this.angle = 60; }
        else if (squareGroups.includes(this.group)) { lockRatio = true; this.ratio = 1.0; lockAngle = true; this.angle = 90; }
        else if (rectGroups.includes(this.group)) { lockAngle = true; this.angle = 90; } 
        
        if (glideGroups.includes(this.group)) { enableGlide = true; }

        if(lockRatio) { ratioRow.classList.add('hidden'); rInput.disabled = true; rInput.value = 100; }
        else { ratioRow.classList.remove('hidden'); rInput.disabled = false; }
        
        if(lockAngle) { angleRow.classList.add('hidden'); aInput.disabled = true; aInput.value = this.angle; }
        else { angleRow.classList.remove('hidden'); aInput.disabled = false; }
        
        if(!enableGlide) { glideRow.classList.add('hidden'); gInput.disabled = true; }
        else { glideRow.classList.remove('hidden'); gInput.disabled = false; }

        this.cachedTransforms = this.getBaseTransforms();
        this.updateViewBounds();
        this.drawGuides();
        this.redrawAll();
    }

    updateViewBounds(w=null, h=null) {
        const width = w || this.width; const height = h || this.height;
        const corners = [
            this.getLatticeTransform(0,0), this.getLatticeTransform(width, 0),
            this.getLatticeTransform(0, height), this.getLatticeTransform(width, height)
        ];
        this.viewBounds.uMin = Math.min(...corners.map(c=>c.u));
        this.viewBounds.uMax = Math.max(...corners.map(c=>c.u));
        this.viewBounds.vMin = Math.min(...corners.map(c=>c.v));
        this.viewBounds.vMax = Math.max(...corners.map(c=>c.v));
        this.viewBounds.rangeU = Math.ceil(this.viewBounds.uMax - this.viewBounds.uMin) + 2;
        this.viewBounds.rangeV = Math.ceil(this.viewBounds.vMax - this.viewBounds.vMin) + 2;
    }

    redrawAll(targetCtx = null, w = null, h = null) {
        const ctx = targetCtx || this.ctx;
        const width = w || this.width; const height = h || this.height;
        if(w && h) this.updateViewBounds(w, h); 
        
        if (!targetCtx) ctx.clearRect(0,0,width,height);
        
        this.drawings.forEach(d => {
            ctx.strokeStyle = d.color; ctx.lineWidth = d.width; ctx.fillStyle = d.color;
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            
            if (d.type === 'pen') {
                this.cachedTransforms.forEach(transform => {
                    const tFirst = transform(d.points[0].u, d.points[0].v);
                    const startK = Math.floor(this.viewBounds.uMin - tFirst[0]);
                    const startR = Math.floor(this.viewBounds.vMin - tFirst[1]);

                    for(let c = 0; c <= this.viewBounds.rangeU; c++) {
                        for(let r = 0; r <= this.viewBounds.rangeV; r++) {
                            const uShift = startK + c; const vShift = startR + r;
                            
                            ctx.beginPath();
                            let p = this.getScreenPoint(tFirst[0] + uShift, tFirst[1] + vShift);
                            ctx.moveTo(p.x, p.y);
                            
                            for(let i=1; i<d.points.length; i++) {
                                const t = transform(d.points[i].u, d.points[i].v);
                                p = this.getScreenPoint(t[0] + uShift, t[1] + vShift);
                                ctx.lineTo(p.x, p.y);
                            }
                            ctx.stroke();
                        }
                    }
                });
            } else {
                const s_orig = d.p1; const e_orig = d.p2;
                const oldTool = this.tool; this.tool = d.type;
                
                this.cachedTransforms.forEach(transform => {
                    const t1 = transform(s_orig.u, s_orig.v);
                    const t2 = transform(e_orig.u, e_orig.v);
                    const startK = Math.floor(this.viewBounds.uMin - t1[0]);
                    const startR = Math.floor(this.viewBounds.vMin - t1[1]);
                    
                    for(let c = 0; c <= this.viewBounds.rangeU; c++) {
                        for(let r = 0; r <= this.viewBounds.rangeV; r++) {
                            const s = this.getScreenPoint(t1[0] + startK + c, t1[1] + startR + r);
                            const e = this.getScreenPoint(t2[0] + startK + c, t2[1] + startR + r);
                            
                            ctx.beginPath();
                            if (this.tool === 'line') { ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y); }
                            else if (this.tool === 'rect') { ctx.rect(s.x, s.y, e.x-s.x, e.y-s.y); }
                            else if (this.tool === 'circle') { const rad = Math.hypot(e.x-s.x, e.y-s.y); ctx.arc(s.x, s.y, rad, 0, Math.PI*2); }
                            ctx.stroke();
                        }
                    }
                });
                this.tool = oldTool;
            }
        });
        
        if(w && h) this.updateViewBounds(this.width, this.height);
    }

    getLatticeTransform(x, y) {
        const rad = this.angle * Math.PI / 180;
        const sin = Math.sin(rad); const cos = Math.cos(rad);
        const v = y / (this.scale * this.ratio * sin);
        const u = (x / this.scale) - (v * this.ratio * cos);
        return { u, v };
    }

    getScreenPoint(u, v) {
        const rad = this.angle * Math.PI / 180;
        const sin = Math.sin(rad); const cos = Math.cos(rad);
        const x = this.scale*u + this.scale*this.ratio*v*cos;
        const y = this.scale*this.ratio*v*sin;
        return { x, y };
    }

    getBaseTransforms() {
        const ops = [];
        const add = (fn) => ops.push(fn);
        const g = this.glide; 
        
        add((u,v) => [u,v]);
        switch(this.group) {
            case 'p1': break;
            case 'p2': add((u,v) => [-u, -v]); break;
            case 'pm': add((u,v) => [-u, v]); break; 
            case 'pg': add((u,v) => [-u, v+g]); break;
            case 'cm': add((u,v) => [-u, v]); add((u,v) => [u+0.5, v+0.5]); add((u,v) => [0.5-u, v+0.5]); break;
            case 'pmm': add((u,v) => [-u,v]); add((u,v) => [u,-v]); add((u,v) => [-u,-v]); break;
            case 'pmg': add((u,v) => [-u,v]); add((u,v) => [u+g, -v]); add((u,v) => [g-u, -v]); break;
            case 'pgg': add((u,v) => [-u,-v]); add((u,v) => [u+0.5, g-v]); add((u,v) => [0.5-u, v+g]); break;
            case 'cmm': 
                add((u,v) => [-u,v]); add((u,v) => [u,-v]); add((u,v) => [-u,-v]);
                add((u,v) => [u+0.5,v+0.5]); add((u,v) => [0.5-u,v+0.5]); add((u,v) => [u+0.5,0.5-v]); add((u,v) => [0.5-u,0.5-v]);
                break;
            case 'p4': add((u,v) => [-v,u]); add((u,v) => [-u,-v]); add((u,v) => [v,-u]); break;
            case 'p4m': 
                add((u,v) => [-v,u]); add((u,v) => [-u,-v]); add((u,v) => [v,-u]);
                add((u,v) => [v,u]); add((u,v) => [-u,v]); add((u,v) => [-v,-u]); add((u,v) => [u,-v]);
                break;
            case 'p4g': 
                add((u,v) => [-v,u]); add((u,v) => [-u,-v]); add((u,v) => [v,-u]);
                add((u,v) => [u+0.5, g-v]); add((u,v) => [g-v, g-u]); add((u,v) => [g-u, v+g]); add((u,v) => [v+g, u+g]);
                break;
            case 'p3': add((u,v) => [-v, u+v]); add((u,v) => [-u-v, u]); break;
            case 'p3m1':
                add((u,v) => [-v, u+v]); add((u,v) => [-u-v, u]);
                add((u,v) => [v, u]); add((u,v) => [u+v, -v]); add((u,v) => [u, -u-v]);
                break;
            case 'p31m':
                add((u,v) => [-v, u+v]); add((u,v) => [-u-v, u]);
                add((u,v) => [u, -v-u]); add((u,v) => [-v, -u]); add((u,v) => [-u-v, -v-(u+v)]);
                break;
            case 'p6':
                 add((u,v) => [-v, u+v]); add((u,v) => [-u-v, u]);
                 add((u,v) => [-u, -v]); add((u,v) => [v, -u-v]); add((u,v) => [u+v, -u]);
                 break;
            case 'p6m':
                 add((u,v) => [-v, u+v]); add((u,v) => [-u-v, u]);
                 add((u,v) => [-u, -v]); add((u,v) => [v, -u-v]); add((u,v) => [u+v, -u]);
                 add((u,v) => [v,u]); 
                 break;
        }
        
        if(this.group === 'p6m') {
            const p6_ops = [];
            const add6 = (f) => p6_ops.push(f);
            add6((u,v)=>[u,v]); add6((u,v)=>[-v, u+v]); add6((u,v)=>[-u-v, u]);
            add6((u,v)=>[-u,-v]); add6((u,v)=>[v, -u-v]); add6((u,v)=>[u+v, -u]);
            
            ops.length = 0; 
            p6_ops.forEach(f => {
                ops.push(f);
                ops.push((u,v) => { const p=f(u,v); return [p[1], p[0]]; });
            });
        }
        return ops;
    }

    drawSymmetrySegment(p1, p2, ctx, w = null, h = null) {
        const width = w || this.width; const height = h || this.height;
        if(w && h) this.updateViewBounds(w, h);

        const l1 = this.getLatticeTransform(p1.x, p1.y);
        const l2 = this.getLatticeTransform(p2.x, p2.y);
        
        ctx.beginPath();
        this.cachedTransforms.forEach(transform => {
            const t1 = transform(l1.u, l1.v);
            const t2 = transform(l2.u, l2.v);
            const startK = Math.floor(this.viewBounds.uMin - t1[0]);
            const startR = Math.floor(this.viewBounds.vMin - t1[1]);
            
            for(let c = 0; c <= this.viewBounds.rangeU; c++) {
                for(let r = 0; r <= this.viewBounds.rangeV; r++) {
                    const uShift = startK + c; const vShift = startR + r;
                    const s = this.getScreenPoint(t1[0] + uShift, t1[1] + vShift);
                    const e = this.getScreenPoint(t2[0] + uShift, t2[1] + vShift);
                    ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y);
                }
            }
        });
        ctx.stroke();
        if(w && h) this.updateViewBounds(this.width, this.height);
    }

    drawDot(p) {
        this.ctx.fillStyle = this.color;
        const oldCap = this.ctx.lineCap; this.ctx.lineCap = 'round';
        this.ctx.lineWidth = this.lineWidth; this.ctx.strokeStyle = this.color;
        this.drawSymmetrySegment(p, p, this.ctx);
        this.ctx.lineCap = oldCap;
    }

    drawShapePreview(p1, p2) {
        this.drawShape(p1, p2, this.pCtx, true);
    }

    drawShape(p1, p2, ctx, isPreview=false, w=null, h=null) {
        const width = w || this.width; const height = h || this.height;
        if(w && h) this.updateViewBounds(w, h);

        const l1 = this.getLatticeTransform(p1.x, p1.y);
        const l2 = this.getLatticeTransform(p2.x, p2.y);
        if(isPreview) { ctx.strokeStyle = this.color; ctx.fillStyle = 'rgba(255,255,255,0.2)'; }
        
        this.cachedTransforms.forEach(transform => {
            const t1 = transform(l1.u, l1.v);
            const t2 = transform(l2.u, l2.v);
            const startK = Math.floor(this.viewBounds.uMin - t1[0]);
            const startR = Math.floor(this.viewBounds.vMin - t1[1]);
            
            for(let c = 0; c <= this.viewBounds.rangeU; c++) {
                for(let r = 0; r <= this.viewBounds.rangeV; r++) {
                    const uShift = startK + c; const vShift = startR + r;
                    const s = this.getScreenPoint(t1[0] + uShift, t1[1] + vShift);
                    const e = this.getScreenPoint(t2[0] + uShift, t2[1] + vShift);
                    
                    ctx.beginPath();
                    if (this.tool === 'line') { ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y); }
                    else if (this.tool === 'rect') { ctx.rect(s.x, s.y, e.x-s.x, e.y-s.y); }
                    else if (this.tool === 'circle') { const rad = Math.hypot(e.x-s.x, e.y-s.y); ctx.arc(s.x, s.y, rad, 0, Math.PI*2); }
                    ctx.stroke();
                }
            }
        });
        if(w && h) this.updateViewBounds(this.width, this.height);
    }

    drawGuides() {
        const c = this.gCtx;
        c.clearRect(0, 0, this.width, this.height);
        if (!this.showGuides) return;
        c.lineWidth = 1; c.strokeStyle = getComputedStyle(document.body).getPropertyValue('--guide-color');
        
        const vb = this.viewBounds;
        const uMin = Math.floor(vb.uMin); const uMax = Math.ceil(vb.uMax);
        const vMin = Math.floor(vb.vMin); const vMax = Math.ceil(vb.vMax);

        c.beginPath();
        for(let u = uMin; u <= uMax; u++) {
            const top = this.getScreenPoint(u, vMin); const bot = this.getScreenPoint(u, vMax);
            c.moveTo(top.x, top.y); c.lineTo(bot.x, bot.y);
        }
        for(let v = vMin; v <= vMax; v++) {
            const left = this.getScreenPoint(uMin, v); const right = this.getScreenPoint(uMax, v);
            c.moveTo(left.x, left.y); c.lineTo(right.x, right.y);
        }
        c.stroke();
        
        c.fillStyle = getComputedStyle(document.body).getPropertyValue('--region-color');
        const p00 = this.getScreenPoint(0,0); const p10 = this.getScreenPoint(1,0);
        const p11 = this.getScreenPoint(1,1); const p01 = this.getScreenPoint(0,1);
        c.beginPath(); c.moveTo(p00.x, p00.y);
        if (['p4m'].includes(this.group)) { c.lineTo(p10.x, p10.y); c.lineTo(this.getScreenPoint(0.5, 0.5).x, this.getScreenPoint(0.5, 0.5).y); }
        else if (['p6m'].includes(this.group)) { const t1 = this.getScreenPoint(0.5, 0); const t2 = this.getScreenPoint(1/3, 1/3); c.lineTo(t1.x, t1.y); c.lineTo(t2.x, t2.y); }
        else if (['p6'].includes(this.group)) { const t1 = this.getScreenPoint(1, 0); const t2 = this.getScreenPoint(0, 1); c.lineTo(t1.x, t1.y); c.lineTo(t2.x, t2.y); }
        else { c.lineTo(p10.x, p10.y); c.lineTo(p11.x, p11.y); c.lineTo(p01.x, p01.y); }
        c.fill();

        const drawMarker = (u, v, type) => {
            const p = this.getScreenPoint(u, v); c.fillStyle = '#fff'; c.beginPath(); const s = 4;
            if (type === 2) { c.moveTo(p.x, p.y-s); c.lineTo(p.x+s, p.y); c.lineTo(p.x, p.y+s); c.lineTo(p.x-s, p.y); }
            else if (type === 3) { c.moveTo(p.x, p.y-s); c.lineTo(p.x+s, p.y+s); c.lineTo(p.x-s, p.y+s); }
            else if (type === 4) { c.rect(p.x-s, p.y-s, s*2, s*2); }
            else if (type === 6) { for(let i=0; i<6; i++) { const ang = i * Math.PI / 3; c.lineTo(p.x + s*Math.cos(ang), p.y + s*Math.sin(ang)); } }
            c.fill();
        };
        const drawLine = (u1, v1, u2, v2, dashed) => {
            const p1 = this.getScreenPoint(u1, v1); const p2 = this.getScreenPoint(u2, v2);
            c.beginPath(); c.strokeStyle = '#fff'; c.setLineDash(dashed ? [6, 4] : []); c.lineWidth = 1.5;
            c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y); c.stroke(); c.setLineDash([]);
        };

        const g = this.glide;
        if (['pm', 'pmm', 'pmg', 'cmm', 'p4m', 'p6m'].includes(this.group)) { for(let u=uMin; u<=uMax; u+=0.5) drawLine(u, vMin, u, vMax, false); }
        if (['pmm', 'cmm', 'p4m'].includes(this.group)) { for(let v=vMin; v<=vMax; v+=0.5) drawLine(uMin, v, uMax, v, false); }
        if (['pg', 'pmg', 'pgg', 'p4g'].includes(this.group)) { for(let u=uMin+0.5; u<=uMax; u+=1) drawLine(u, vMin, u, vMax, true); }

        for(let u=uMin; u<=uMax; u++) { for(let v=vMin; v<=vMax; v++) {
            if (['p2', 'pmm', 'cmm', 'pmg', 'pgg'].includes(this.group)) { drawMarker(u, v, 2); drawMarker(u+0.5, v+0.5, 2); if(this.group !== 'p2') { drawMarker(u+0.5, v, 2); drawMarker(u, v+0.5, 2); } }
            if (['p4', 'p4m', 'p4g'].includes(this.group)) { drawMarker(u, v, 4); drawMarker(u+0.5, v+0.5, 4); if(this.group === 'p4m') { drawMarker(u+0.5, v, 2); drawMarker(u, v+0.5, 2); } }
            if (['p3', 'p3m1', 'p31m', 'p6', 'p6m'].includes(this.group)) {
                 const isP6 = ['p6', 'p6m'].includes(this.group); drawMarker(u, v, isP6 ? 6 : 3);
                 if(isP6) { drawMarker(u+1/3, v+1/3, 3); drawMarker(u+2/3, v+2/3, 3); drawMarker(u+0.5, v, 2); drawMarker(u, v+0.5, 2); drawMarker(u+0.5, v+0.5, 2); }
                 else { drawMarker(u+1/3, v+1/3, 3); drawMarker(u+2/3, v+2/3, 3); }
            }
        }}
    }

    saveState() {
        this.historyStep++;
        this.history = this.history.slice(0, this.historyStep);
        this.history.push(JSON.stringify(this.drawings));
        if(this.history.length > 20) { this.history.shift(); this.historyStep--; }
    }
    undo() {
        if(this.historyStep > 0) {
            this.historyStep--;
            this.restoreState(this.history[this.historyStep]);
        } else { this.clear(false); }
    }
    restoreState(json) {
        this.drawings = JSON.parse(json);
        this.redrawAll();
    }
    clear(save=true) {
        this.drawings = [];
        this.redrawAll();
        if(save) { this.historyStep = -1; this.history = []; this.saveState(); }
    }
    download() {
        const link = document.createElement('a');
        link.download = 'teselados.png';
        const t = document.createElement('canvas'); t.width=this.width; t.height=this.height;
        const tx = t.getContext('2d'); tx.fillStyle = '#050505'; tx.fillRect(0,0,this.width,this.height);
        tx.drawImage(this.mainCanvas,0,0);
        link.href = t.toDataURL(); link.click();
    }
    
    downloadTile() {
        let w, h;
        const hexGroups = ['p3', 'p3m1', 'p31m', 'p6', 'p6m'];
        const isHex = hexGroups.includes(this.group);
        if(isHex) { w = this.scale; h = this.scale * Math.sqrt(3); } 
        else { w = this.scale; h = this.scale * this.ratio; }
        
        const t = document.createElement('canvas'); t.width = w; t.height = h;
        const tx = t.getContext('2d'); tx.fillStyle = '#050505'; tx.fillRect(0, 0, w, h);
        this.redrawAll(tx, w, h);
        const link = document.createElement('a'); link.download = 'azulejo.png'; link.href = t.toDataURL(); link.click();
    }
}

const app = new WallpaperApp();
</script>
</body>
</html>
