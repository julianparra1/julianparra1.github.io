<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>¬°Explorador de Pantalla T√°ctil Interactivo!</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Fredoka', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            overflow: hidden;
            user-select: none;
        }
        
        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .header {
            text-align: center;
            padding: 8px 15px;
            background: linear-gradient(45deg, #333, #555);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 100;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .university-logo {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            height: 32px;
            width: auto;
            opacity: 0.9;
            transition: opacity 0.3s ease;
            object-fit: cover;
            object-position: center;
        }
        
        .university-logo:hover {
            opacity: 1;
        }
        
        .logo-separator {
            position: absolute;
            left: 50px;
            top: 50%;
            transform: translateY(-50%);
            width: 1px;
            height: 25px;
            background: linear-gradient(to bottom, transparent, #fff, transparent);
            opacity: 0.5;
        }
        
        .faculty-logo {
            position: absolute;
            left: 63px;
            top: 50%;
            transform: translateY(-50%);
            height: 28px;
            width: auto;
            opacity: 0.9;
            transition: opacity 0.3s ease;
            object-fit: cover;
            object-position: center;
        }
        
        .faculty-logo:hover {
            opacity: 1;
        }
        
        .event-title {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75em;
            font-weight: 600;
            color: #4CAF50;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            text-align: right;
            line-height: 1.2;
        }
        
        .event-year {
            color: #FFD54F;
            font-weight: 700;
        }
        
        .header h1 {
            font-size: 1.2em;
            font-weight: 600;
            color: #fff;
            margin: 0;
        }
        
        .game-area {
            flex: 1;
            position: relative;
            background: linear-gradient(45deg, #1e3c72, #2a5298);
        }
        
        #webgl-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }
        
        .info-panel {
            position: absolute;
            bottom: 130px;
            left: 20px;
            background: rgba(25, 35, 50, 0.85);
            border: 1px solid rgba(80, 120, 160, 0.3);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.25);
            color: #E8F4F8;
            max-width: 300px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            z-index: 1000;
            font-size: 0.9em;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }
        
        .info-panel:hover {
            opacity: 1;
        }
        
        .info-panel.attention {
            opacity: 1;
            border-color: rgba(76, 175, 80, 0.6);
            box-shadow: 0 4px 16px rgba(76, 175, 80, 0.3);
        }
        
        .technical-panel {
            position: absolute;
            bottom: 150px;
            right: 20px;
            background: rgba(25, 35, 50, 0.85);
            border: 1px solid rgba(80, 120, 160, 0.3);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.25);
            color: #E8F4F8;
            max-width: 320px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            z-index: 1000;
            font-size: 0.85em;
            opacity: 0.4; /* More transparent by default */
            transition: opacity 0.3s ease;
        }
        
        .technical-panel:hover {
            opacity: 1;
        }
        
        .technical-panel.attention {
            opacity: 1;
            border-color: rgba(255, 193, 7, 0.6);
            box-shadow: 0 4px 16px rgba(255, 193, 7, 0.3);
        }
        
        .tech-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #E8F4F8;
            margin-bottom: 12px;
            text-align: center;
            position: relative;
            z-index: 1;
        }
        
        .tech-title::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 2px;
            background: rgba(80, 120, 160, 0.8);
            border-radius: 2px;
        }
        
        .tech-section {
            margin-bottom: 12px;
            padding: 12px;
            background: rgba(40, 60, 80, 0.6);
            border-radius: 8px;
            border: 1px solid rgba(80, 120, 160, 0.3);
            position: relative;
        }
        
        .tech-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: #42A5F5;
            border-radius: 0 2px 2px 0;
        }
        
        .tech-section-title {
            font-size: 1em;
            font-weight: 600;
            color: #90CAF9;
            margin-bottom: 8px;
            padding-left: 8px;
        }
        
        .tech-text {
            font-size: 0.8em;
            line-height: 1.4;
            color: #D0E8FF;
            padding-left: 8px;
        }
        
        .layer-info {
            display: grid;
            grid-template-columns: 1fr;
            gap: 6px;
            margin: 8px 0;
            padding-left: 8px;
        }
        
        .layer-item {
            background: rgba(50, 70, 90, 0.6);
            border-radius: 6px;
            padding: 8px;
            border: 1px solid rgba(80, 120, 160, 0.3);
            position: relative;
            font-size: 0.8em;
            color: #E8F4F8;
        }
        
        .layer-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 3px;
            height: 100%;
            border-radius: 0 2px 2px 0;
        }
        
        .layer-top::before { background: #FF7043; }
        .layer-bottom::before { background: #42A5F5; }
        .layer-spacer::before { background: #FFC107; }
        
        .status-display {
            margin-bottom: 12px;
            padding: 12px;
            background: rgba(40, 60, 80, 0.6);
            border-radius: 8px;
        }
        
        .status-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #90EE90;
            margin-bottom: 6px;
        }
        
        .status-text {
            font-size: 0.95em;
            color: #D0E8FF;
            line-height: 1.3;
        }
        
        .voltage-readings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 12px 0;
        }
        
        .voltage-card {
            background: rgba(50, 70, 90, 0.6);
            border: 1px solid rgba(80, 120, 160, 0.4);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            color: #E8F4F8;
            transition: all 0.3s ease;
        }
        
        .voltage-card.measuring {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
        }
        
        .voltage-label {
            font-size: 0.8em;
            font-weight: 500;
            margin-bottom: 4px;
            opacity: 0.8;
            color: #B8D4EA;
        }
        
        .voltage-value {
            font-size: 1.2em;
            font-weight: 600;
            color: #90EE90;
        }
        
        .voltage-details {
            font-size: 0.75em;
            opacity: 0.7;
            margin-top: 2px;
            color: #A8C8E8;
        }
        
        .measurement-process {
            background: rgba(45, 65, 85, 0.6);
            border: 1px solid rgba(76, 175, 80, 0.4);
            border-radius: 8px;
            padding: 10px;
            margin: 12px 0;
            color: #E8F4F8;
            position: relative;
        }
        
        .measurement-process::before {
            content: '‚óè';
            position: absolute;
            top: 8px;
            right: 12px;
            color: #4CAF50;
            font-size: 1.2em;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .process-title {
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 6px;
            text-align: center;
            color: #90EE90;
        }
        
        .process-step {
            font-size: 0.85em;
            text-align: center;
            margin-bottom: 6px;
            color: #D0E8FF;
        }
        
        .resistance-info {
            font-size: 0.75em;
            text-align: center;
            opacity: 0.8;
            color: #A8C8E8;
        }
        
        .position-calculator {
            background: rgba(45, 65, 85, 0.6);
            border: 1px solid rgba(255, 193, 7, 0.4);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            color: #E8F4F8;
            opacity: 0.4; /* More transparent by default */
            transition: opacity 0.3s ease;
        }
        
        .position-calculator:hover {
            opacity: 1;
        }
        
        .position-calculator.attention {
            opacity: 1;
            border-color: rgba(33, 150, 243, 0.6);
            box-shadow: 0 4px 16px rgba(33, 150, 243, 0.3);
        }
        
        .calculator-title {
            font-size: 0.95em;
            font-weight: 600;
            margin-bottom: 8px;
            text-align: center;
            color: #FFD54F;
        }
        
        .position-formula {
            background: rgba(60, 80, 100, 0.6);
            border-radius: 6px;
            padding: 8px 12px;
            margin: 6px 0;
            font-size: 0.85em;
            font-weight: 500;
            color: #D0E8FF;
            font-family: 'Courier New', monospace;
            text-align: center;
            border: 1px solid rgba(100, 140, 180, 0.3);
        }
        
        .math-formula {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            letter-spacing: 0.5px;
        }
        
        .math-var {
            font-style: italic;
            color: #90CAF9;
            font-weight: 600;
        }
        
        .math-operator {
            color: #FFD54F;
            font-weight: bold;
            margin: 0 2px;
        }
        
        .math-number {
            color: #81C784;
            font-weight: 600;
        }
        
        .math-unit {
            color: #F8BBD9;
            font-size: 0.9em;
        }
        
        .math-result {
            color: #FFB74D; /* Orange for results */
            font-family: "Courier New", monospace;
            font-weight: bold;
            background: rgba(255, 183, 77, 0.1);
            padding: 1px 3px;
            border-radius: 2px;
        }
        
        .math-fraction {
            display: inline-block;
            vertical-align: middle;
            text-align: center;
        }
        
        .math-numerator {
            display: block;
            border-bottom: 1px solid #D0E8FF;
            padding-bottom: 2px;
            margin-bottom: 2px;
        }
        
        .math-denominator {
            display: block;
            padding-top: 2px;
        }
        
        .calculated-position {
            background: rgba(60, 80, 100, 0.8);
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
            text-align: center;
            font-weight: 600;
            font-size: 0.9em;
            color: #FFD54F;
        }
        
        .fun-messages {
            position: absolute;
            bottom: 50px;
            right: 20px;
            background: rgba(255, 107, 107, 0.95);
            border-radius: 20px;
            padding: 15px 20px;
            color: white;
            font-size: 1.2em;
            font-weight: 600;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.5s ease;
            max-width: 300px;
            text-align: center;
            z-index: 50;
        }
        
        .fun-messages.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .controls-hint {
            position: absolute;
            bottom: 50px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            border-radius: 15px;
            padding: 12px 15px;
            color: white;
            font-size: 1em;
            font-weight: 500;
            backdrop-filter: blur(10px);
            z-index: 50;
        }
        
        .key {
            background: #333;
            color: #fff;
            padding: 4px 8px;
            border-radius: 6px;
            font-weight: 600;
            margin: 0 4px;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        
        .bounce {
            animation: bounce 1s;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 8px 32px rgba(255, 107, 107, 0.3); }
            50% { box-shadow: 0 8px 32px rgba(255, 107, 107, 0.8); }
        }
        
        .glowing {
            animation: glow 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <img src="https://comunicacioninstitucional.uabc.mx/wp-content/uploads/2024/03/escudo-actualizado-2022-300ox.png" 
                 alt="Universidad Aut√≥noma de Baja California" 
                 class="university-logo">
            <div class="logo-separator"></div>
            <img src="https://ciencias.ens.uabc.mx/wp-content/themes/THEME-FC/images/object1360936079.png" 
                 alt="Facultad de Ciencias" 
                 class="faculty-logo">
            <h1>Pantalla T√°ctil Resistiva - Demostraci√≥n T√©cnica</h1>
            <div class="event-title">
                XLII SEMANA DE<br>
                CIENCIAS <span class="event-year">2025</span>
            </div>
        </div>
        
        <div class="game-area">
            <canvas id="webgl-canvas"></canvas>
            
            <div class="info-panel">
                <div class="status-display">
                    <div class="status-title" id="status-title">¬°Listo para Empezar!</div>
                    <div class="status-text" id="status-text">¬°Haz clic en cualquier parte de la pantalla para crear un punto t√°ctil!</div>
                </div>
                
                <div class="voltage-readings">
                    <div class="voltage-card">
                        <div class="voltage-label">Voltaje X (ADC)</div>
                        <div class="voltage-value" id="x-voltage">0.00V</div>
                        <div class="voltage-details" id="x-adc">ADC: 0 / 4095</div>
                    </div>
                    <div class="voltage-card">
                        <div class="voltage-label">Voltaje Y (ADC)</div>
                        <div class="voltage-value" id="y-voltage">0.00V</div>
                        <div class="voltage-details" id="y-adc">ADC: 0 / 4095</div>
                    </div>
                </div>
                
                <div class="measurement-process">
                    <div class="process-title">Estado de Medici√≥n</div>
                    <div class="process-step" id="measurement-step">Esperando contacto...</div>
                    <div class="resistance-info">
                        <span>R_x: <span id="resistance-x">‚àû Œ©</span></span> | 
                        <span>R_y: <span id="resistance-y">‚àû Œ©</span></span>
                    </div>
                </div>
                
                <div class="position-calculator">
                    <div class="calculator-title">üßÆ Calculadora de Posici√≥n</div>
                    <div class="position-formula" id="x-formula">
                        X = (Voltaje X √∑ 3.3V) √ó Ancho
                    </div>
                    <div class="position-formula" id="y-formula">
                        Y = (Voltaje Y √∑ 3.3V) √ó Alto
                    </div>
                    <div class="calculated-position" id="calculated-position">
                        Posici√≥n: Esperando toque...
                    </div>
                </div>
            </div>
            
            <div class="technical-panel">
                <div class="tech-title">üî¨ Funcionamiento T√©cnico</div>
                
                <div class="tech-section">
                    <div class="tech-section-title">Estructura de Capas</div>
                    <div class="layer-info">
                        <div class="layer-item layer-top">
                            <strong>Capa Superior:</strong> Film conductor flexible (ITO)
                        </div>
                        <div class="layer-item layer-spacer">
                            <strong>Separadores:</strong> Puntos aislantes microsc√≥picos
                        </div>
                        <div class="layer-item layer-bottom">
                            <strong>Capa Inferior:</strong> Sustrato conductor r√≠gido
                        </div>
                    </div>
                </div>
                
                <div class="tech-section">
                    <div class="tech-section-title">Principio de Medici√≥n</div>
                    <div class="tech-text">
                        <strong>Divisor de Voltaje:</strong><br>
                        ‚Ä¢ Se aplica voltaje entre extremos<br>
                        ‚Ä¢ El contacto crea un punto de medici√≥n<br>
                        ‚Ä¢ La posici√≥n determina la resistencia<br>
                        ‚Ä¢ V_medido = V_total √ó (R_posici√≥n / R_total)
                    </div>
                </div>
                
                <div class="tech-section">
                    <div class="tech-section-title">Proceso de Detecci√≥n</div>
                    <div class="tech-text">
                        <strong>1. Eje X:</strong> Voltaje en bordes izq/der<br>
                        <strong>2. Eje Y:</strong> Voltaje en bordes sup/inf<br>
                        <strong>3. ADC:</strong> Conversi√≥n anal√≥gica-digital<br>
                        <strong>4. C√°lculo:</strong> Coordenadas normalizadas
                    </div>
                </div>
            </div>
            
            <div class="controls-hint">
                <span class="key">‚Üê‚Üí</span> Pasos | 
                <span class="key">R</span> Reiniciar<br>
                <small style="opacity: 0.8;">üñ±Ô∏è Arrastra para rotar ‚Ä¢ Rueda para zoom ‚Ä¢ Clic derecho para mover</small>
            </div>
            
            <div class="fun-messages" id="fun-messages">
                ¬°Excelente trabajo! üåü
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Estado del juego
        let currentStep = 0;
        let totalSteps = 6;
        let touchPoint = { x: 0, y: 0, z: 0 };
        let lastClickTime = 0;
        
        // Mensajes divertidos para ni√±os
        const funMessages = [
            "¬°Incre√≠ble! ¬°Vamos a explorar! üöÄ",
            "¬°Mira c√≥mo se mueve el dedo! üëÜ",
            "¬°Mira! ¬°La pantalla se dobla! üòÆ",
            "¬°Ahora medimos la direcci√≥n X! üìè",
            "¬°Es hora de la direcci√≥n Y! üìê",
            "¬°Encontramos el lugar exacto! üéØ",
            "¬°Incre√≠ble trabajo, explorador! ‚≠ê"
        ];
        
        const stepTitles = [
            "Sistema Listo",
            "Aproximaci√≥n del Dedo",
            "Contacto y Deformaci√≥n", 
            "Medici√≥n Eje X (Voltaje)",
            "Medici√≥n Eje Y (Voltaje)",
            "C√°lculo de Coordenadas",
            "Proceso Completo"
        ];
        
        const stepTexts = [
            "Haz clic en cualquier parte para iniciar el proceso de detecci√≥n t√°ctil",
            "El dedo se aproxima hacia el punto de contacto seleccionado",
            "La capa superior se deforma al hacer contacto, creando un circuito cerrado",
            "Aplicando voltaje en el eje X y midiendo la resistencia en el punto de contacto",
            "Aplicando voltaje en el eje Y y midiendo la resistencia en el punto de contacto", 
            "Calculando las coordenadas finales basadas en las mediciones de voltaje",
            "Proceso de detecci√≥n t√°ctil completado. ¬°Haz clic para repetir!"
        ];

        // Elementos de la UI
        const canvas = document.getElementById('webgl-canvas');
        const statusTitle = document.getElementById('status-title');
        const statusText = document.getElementById('status-text');
        const xVoltage = document.getElementById('x-voltage');
        const yVoltage = document.getElementById('y-voltage');
        const xAdc = document.getElementById('x-adc');
        const yAdc = document.getElementById('y-adc');
        const measurementStep = document.getElementById('measurement-step');
        const resistanceX = document.getElementById('resistance-x');
        const resistanceY = document.getElementById('resistance-y');
        const funMessagesDiv = document.getElementById('fun-messages');
        const xFormula = document.getElementById('x-formula');
        const yFormula = document.getElementById('y-formula');
        const calculatedPosition = document.getElementById('calculated-position');

        // Configuraci√≥n de Three.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x001122);
        
        // Constants needed for setup
        const SCREEN_SIZE = 60;
        const SEGMENTS = 30;
        const GAP = 8;
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Add orbit controls for 3D navigation
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 200;
        controls.minDistance = 20;
        controls.target.set(0, 0, GAP/2);
        controls.enablePan = true;
        controls.panSpeed = 0.8;

        // Iluminaci√≥n optimizada para mostrar el pit sin sombras molestas
        const ambientLight = new THREE.AmbientLight(0x404040, 1.2); // Increased ambient light
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); // Reduced intensity
        directionalLight.position.set(20, 30, 40);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 200;
        directionalLight.shadow.camera.left = -80;
        directionalLight.shadow.camera.right = 80;
        directionalLight.shadow.camera.top = 80;
        directionalLight.shadow.camera.bottom = -80;
        directionalLight.shadow.bias = -0.0001; // Reduced shadow bias
        scene.add(directionalLight);

        // Enhanced spotlight for pit illumination
        const valleySpotlight = new THREE.SpotLight(0x6699ff, 1.2, 80, Math.PI / 4, 0.3, 1.5);
        valleySpotlight.position.set(0, 0, 35);
        valleySpotlight.target.position.set(0, 0, 0);
        valleySpotlight.castShadow = false; // Disable shadows from pit light
        scene.add(valleySpotlight);
        scene.add(valleySpotlight.target);

        // Soft rim lighting for better deformation visibility
        const rimLight = new THREE.DirectionalLight(0x88ccff, 0.3);
        rimLight.position.set(-30, -30, 20);
        rimLight.castShadow = false; // No shadows from rim light
        scene.add(rimLight);

        // Enhanced point light for touch interaction
        const pointLight = new THREE.PointLight(0xffeb3b, 0, 120, 1.8);
        pointLight.castShadow = false; // No shadows from interaction light
        scene.add(pointLight);

        // Crear part√≠culas coloridas para el fondo
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 200;
        const posArray = new Float32Array(particlesCount * 3);
        const colorArray = new Float32Array(particlesCount * 3);

        for(let i = 0; i < particlesCount * 3; i += 3) {
            posArray[i] = (Math.random() - 0.5) * 200;
            posArray[i + 1] = (Math.random() - 0.5) * 200;
            posArray[i + 2] = (Math.random() - 0.5) * 200;
            
            colorArray[i] = Math.random();
            colorArray[i + 1] = Math.random();
            colorArray[i + 2] = Math.random();
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

        const particlesMaterial = new THREE.PointsMaterial({
            size: 2,
            vertexColors: true,
            transparent: true,
            opacity: 0.6
        });

        const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particlesMesh);

        // Crear capas de pantalla t√°ctil (constants already declared above)
        const bottomGeometry = new THREE.PlaneGeometry(SCREEN_SIZE, SCREEN_SIZE, SEGMENTS, SEGMENTS);
        const topGeometry = new THREE.PlaneGeometry(SCREEN_SIZE, SCREEN_SIZE, SEGMENTS, SEGMENTS);

        const bottomMaterial = new THREE.MeshLambertMaterial({ 
            vertexColors: true, 
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.9
        });
        
        const topMaterial = new THREE.MeshLambertMaterial({ 
            vertexColors: true, 
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.7
        });

        const bottomLayer = new THREE.Mesh(bottomGeometry, bottomMaterial);
        const topLayer = new THREE.Mesh(topGeometry, topMaterial);
        
        bottomLayer.position.z = 0;
        topLayer.position.z = GAP;
        bottomLayer.receiveShadow = false; // Disable shadow receiving to avoid distracting shadows
        topLayer.castShadow = true;
        topLayer.receiveShadow = true;
        // Disable bottom layer shadow casting to keep focus on the pit
        bottomLayer.castShadow = false;

        scene.add(bottomLayer);
        scene.add(topLayer);

        // Crear etiquetas para las capas
        function createTextSprite(text, color, size = 16) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = color;
            context.font = `${size}px Arial`;
            context.textAlign = 'center';
            context.fillText(text, 128, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(20, 5, 1);
            
            return sprite;
        }

        // Etiquetas de las capas organizadas
        const topLayerLabel = createTextSprite('Capa Superior (ITO)', '#FF5722', 12);
        topLayerLabel.position.set(0, -40, GAP + 8);
        scene.add(topLayerLabel);

        const bottomLayerLabel = createTextSprite('Capa Inferior (Sustrato)', '#2196F3', 12);
        bottomLayerLabel.position.set(0, -50, -8);
        scene.add(bottomLayerLabel);

        const spacerLabel = createTextSprite('Separadores', '#FFC107', 10);
        spacerLabel.position.set(25, -35, GAP/2);
        scene.add(spacerLabel);

        // Store spacer references for interaction
        const spacers = [];
        
        // Crear puntos de separador visuales (reducidos y organizados)
        const spacerGeometry = new THREE.SphereGeometry(0.8, 8, 8);
        const spacerMaterial = new THREE.MeshBasicMaterial({ color: 0xFFC107 });
        
        // Solo crear algunos separadores estrat√©gicamente ubicados
        for (let i = 0; i < 6; i++) {
            for (let j = 0; j < 6; j++) {
                const spacer = new THREE.Mesh(spacerGeometry, spacerMaterial);
                const spacerPos = {
                    x: (i - 2.5) * 12,
                    y: (j - 2.5) * 12,
                    z: GAP/2
                };
                spacer.position.set(spacerPos.x, spacerPos.y, spacerPos.z);
                spacer.userData.originalPosition = spacerPos;
                spacer.userData.originalScale = 1;
                scene.add(spacer);
                spacers.push(spacer);
            }
        }

        // Guardar posiciones originales
        const originalPositions = topLayer.geometry.attributes.position.array.slice();
        const originalBottomPositions = bottomLayer.geometry.attributes.position.array.slice();

        // Crear dedo
        const fingerGeometry = new THREE.CylinderGeometry(4, 3.5, 20, 16);
        const fingerMaterial = new THREE.MeshLambertMaterial({ color: 0xffb380 });
        const finger = new THREE.Mesh(fingerGeometry, fingerMaterial);
        finger.rotation.x = Math.PI / 2;
        finger.castShadow = true;
        finger.position.set(0, 0, 50);
        scene.add(finger);

        // Configuraci√≥n de c√°mara
        camera.position.set(0, -100, 80);
        camera.lookAt(0, 0, GAP/2);

        // Estado de animaci√≥n
        let deformProgress = 0;
        let fingerAnimating = false;

        function updateLayerColors(layer, type) {
            const positions = layer.geometry.attributes.position;
            const colors = new Float32Array(positions.count * 3);
            
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                let r, g, b;

                if (type === 'x') {
                    const intensity = (x + SCREEN_SIZE / 2) / SCREEN_SIZE;
                    r = intensity * 0.8 + 0.2;
                    g = 0.3;
                    b = (1 - intensity) * 0.8 + 0.2;
                } else if (type === 'y') {
                    const intensity = (y + SCREEN_SIZE / 2) / SCREEN_SIZE;
                    r = (1 - intensity) * 0.8 + 0.2;
                    g = intensity * 0.8 + 0.2;
                    b = 0.8;
                } else {
                    r = 0.4;
                    g = 0.8;
                    b = 1.0;
                }

                colors[i * 3] = r;
                colors[i * 3 + 1] = g;
                colors[i * 3 + 2] = b;
            }

            layer.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        }

        function deformLayer() {
            const topPositions = topLayer.geometry.attributes.position;
            const bottomPositions = bottomLayer.geometry.attributes.position;
            const sigma = SCREEN_SIZE / 6; // Tighter deformation area
            const maxDeform = GAP * 0.95; // Deformation almost reaches bottom layer
            
            let maxDeformationAtTouch = 0; // Track maximum deformation at touch point
            
            // Deform top layer
            for (let i = 0; i < topPositions.count; i++) {
                const x = topPositions.getX(i);
                const y = topPositions.getY(i);
                const originalZ = originalPositions[i * 3 + 2];
                
                const distance = Math.sqrt(
                    Math.pow(x - touchPoint.x, 2) + 
                    Math.pow(y - touchPoint.y, 2)
                );
                
                // More realistic gaussian falloff with material tension
                const influence = Math.exp(-(distance * distance) / (2 * sigma * sigma));
                
                // Add material resistance - deformation decreases with distance
                const materialTension = 1 - (distance / (SCREEN_SIZE * 0.4));
                const adjustedInfluence = influence * Math.max(0, materialTension);
                
                // More realistic deformation curve
                const deformation = adjustedInfluence * maxDeform * Math.pow(deformProgress, 1.5);
                
                // Track maximum deformation at the touch point for finger positioning
                if (distance < 2) { // Very close to touch point
                    maxDeformationAtTouch = Math.max(maxDeformationAtTouch, deformation);
                }
                
                topPositions.setZ(i, originalZ - deformation);
            }
            topPositions.needsUpdate = true;
            
            // Deform bottom layer slightly when top layer approaches (contact effect)
            if (deformProgress > 0.5) {
                for (let i = 0; i < bottomPositions.count; i++) {
                    const x = bottomPositions.getX(i);
                    const y = bottomPositions.getY(i);
                    
                    const distance = Math.sqrt(
                        Math.pow(x - touchPoint.x, 2) + 
                        Math.pow(y - touchPoint.y, 2)
                    );
                    
                    const influence = Math.exp(-(distance * distance) / (2 * sigma * sigma));
                    
                    // Bottom layer deforms upward slightly when contacted
                    const bottomDeformation = influence * (GAP * 0.15) * Math.pow((deformProgress - 0.5) * 2, 2);
                    
                    bottomPositions.setZ(i, bottomDeformation);
                }
                bottomPositions.needsUpdate = true;
            } else {
                // Reset bottom layer when not in contact
                for (let i = 0; i < bottomPositions.count; i++) {
                    bottomPositions.setZ(i, 0);
                }
                bottomPositions.needsUpdate = true;
            }
            
            // Update finger position to follow the deformation but stay above surface
            if (deformProgress > 0) {
                // Keep finger above the deformed surface by a safe margin
                const fingerTargetZ = GAP + 4 - (maxDeformationAtTouch * 0.7);
                finger.position.z = Math.max(fingerTargetZ, GAP + 5);
            }
            
            // Interact with spacers - compress them when deformation reaches them
            spacers.forEach(spacer => {
                const distance = Math.sqrt(
                    Math.pow(spacer.userData.originalPosition.x - touchPoint.x, 2) + 
                    Math.pow(spacer.userData.originalPosition.y - touchPoint.y, 2)
                );
                
                const spacerInfluence = Math.exp(-(distance * distance) / (2 * sigma * sigma));
                
                if (spacerInfluence > 0.1 && deformProgress > 0.3) {
                    // Compress spacer - make it compress more realistically
                    const compression = spacerInfluence * deformProgress * 0.8;
                    spacer.scale.z = spacer.userData.originalScale * (1 - compression);
                    
                    // Position spacer to be compressed between layers
                    const compressedGap = GAP * (1 - compression * 0.7);
                    spacer.position.z = compressedGap / 2;
                    
                    // Change color to show compression stress
                    const stress = compression;
                    spacer.material.color.setRGB(
                        0.8 + stress * 0.2,
                        0.8 - stress * 0.4,
                        0.2 + stress * 0.3
                    );
                } else {
                    // Reset to original state
                    spacer.scale.z = spacer.userData.originalScale;
                    spacer.position.z = spacer.userData.originalPosition.z;
                    spacer.material.color.setHex(0xFFC107);
                }
            });
        }

        function showFunMessage(message) {
            funMessagesDiv.textContent = message;
            funMessagesDiv.classList.add('show');
            funMessagesDiv.classList.add('bounce');
            
            setTimeout(() => {
                funMessagesDiv.classList.remove('bounce');
            }, 1000);
            
            setTimeout(() => {
                funMessagesDiv.classList.remove('show');
            }, 3000);
        }

        function updatePositionCalculator(xVal, yVal) {
            // Calcular posici√≥n basada en voltajes en el rango (0,0) a (100,100)
            const maxVoltage = 3.3;
            
            // Convertir voltajes a coordenadas 0-100
            const calculatedX = (xVal / maxVoltage) * 100;
            const calculatedY = (yVal / maxVoltage) * 100;
            
            // Actualizar f√≥rmulas con valores reales y matem√°tica LaTeX-style
            xFormula.innerHTML = `
                <span class="math-var">X</span> <span class="math-operator">=</span> 
                <span class="math-operator">(</span><span class="math-number">${xVal.toFixed(2)}</span><span class="math-unit">V</span> 
                <span class="math-operator">√∑</span> <span class="math-number">3.3</span><span class="math-unit">V</span><span class="math-operator">)</span> 
                <span class="math-operator">√ó</span> <span class="math-number">100</span> 
                <span class="math-operator">=</span> <span class="math-result">${calculatedX.toFixed(1)}</span>
            `;
            
            yFormula.innerHTML = `
                <span class="math-var">Y</span> <span class="math-operator">=</span> 
                <span class="math-operator">(</span><span class="math-number">${yVal.toFixed(2)}</span><span class="math-unit">V</span> 
                <span class="math-operator">√∑</span> <span class="math-number">3.3</span><span class="math-unit">V</span><span class="math-operator">)</span> 
                <span class="math-operator">√ó</span> <span class="math-number">100</span> 
                <span class="math-operator">=</span> <span class="math-result">${calculatedY.toFixed(1)}</span>
            `;
            
            // Mostrar posici√≥n calculada con formato matem√°tico
            calculatedPosition.innerHTML = `
                <strong>Posici√≥n:</strong> 
                <span class="math-operator">(</span><span class="math-result">${calculatedX.toFixed(1)}</span>, 
                <span class="math-result">${calculatedY.toFixed(1)}</span><span class="math-operator">)</span>
            `;
            
            // A√±adir efectos visuales
            if (xVal > 0 && yVal > 0) {
                calculatedPosition.classList.add('pulse');
                setTimeout(() => {
                    calculatedPosition.classList.remove('pulse');
                }, 2000);
            }
        }

        function updateStep() {
            statusTitle.textContent = stepTitles[currentStep];
            statusText.textContent = stepTexts[currentStep];
            
            // Reset attention states instead of hiding panels
            document.querySelectorAll('.info-panel, .technical-panel, .position-calculator').forEach(panel => {
                panel.classList.remove('attention');
            });
            document.querySelectorAll('.voltage-card').forEach(card => {
                card.classList.remove('measuring');
            });
            
            // Resetear estados
            pointLight.intensity = 0;
            deformProgress = 0;
            fingerAnimating = false;
            
            // Actualizar displays de voltaje
            const xVal = ((touchPoint.x + SCREEN_SIZE/2) / SCREEN_SIZE) * 3.3;
            const yVal = ((touchPoint.y + SCREEN_SIZE/2) / SCREEN_SIZE) * 3.3;
            const xAdcVal = Math.round((xVal / 3.3) * 4095);
            const yAdcVal = Math.round((yVal / 3.3) * 4095);
            const xRes = (xVal / 3.3) * 1000; // Resistencia simulada en Œ©
            const yRes = (yVal / 3.3) * 1000;

            switch(currentStep) {
                case 0: // Listo
                    finger.position.set(0, 0, 50);
                    updateLayerColors(bottomLayer, 'neutral');
                    updateLayerColors(topLayer, 'neutral');
                    xVoltage.textContent = "0.00V";
                    yVoltage.textContent = "0.00V";
                    xAdc.textContent = "ADC: 0 / 4095";
                    yAdc.textContent = "ADC: 0 / 4095";
                    measurementStep.textContent = "Esperando contacto...";
                    resistanceX.textContent = "‚àû Œ©";
                    resistanceY.textContent = "‚àû Œ©";
                    calculatedPosition.textContent = "Posici√≥n: Esperando toque...";
                    xFormula.innerHTML = `
                        <span class="math-var">X</span> <span class="math-operator">=</span> 
                        <span class="math-operator">(</span><span class="math-var">Voltaje X</span> 
                        <span class="math-operator">√∑</span> <span class="math-number">3.3</span><span class="math-unit">V</span><span class="math-operator">)</span> 
                        <span class="math-operator">√ó</span> <span class="math-number">100</span>
                    `;
                    yFormula.innerHTML = `
                        <span class="math-var">Y</span> <span class="math-operator">=</span> 
                        <span class="math-operator">(</span><span class="math-var">Voltaje Y</span> 
                        <span class="math-operator">√∑</span> <span class="math-number">3.3</span><span class="math-unit">V</span><span class="math-operator">)</span> 
                        <span class="math-operator">√ó</span> <span class="math-number">100</span>
                    `;
                    // Reset to default view
                    animateCamera(0, -100, 80, 0, 0, GAP/2);
                    break;
                    
                case 1: // Moviendo dedo
                    fingerAnimating = true;
                    measurementStep.textContent = "Aproximando al punto de contacto...";
                    animateFinger();
                    // Side view to see finger approach
                    animateCamera(60, -40, 40, touchPoint.x, touchPoint.y, GAP/2);
                    break;
                    
                case 2: // Contacto
                    deformProgress = 1;
                    pointLight.position.set(touchPoint.x, touchPoint.y, touchPoint.z);
                    pointLight.intensity = 2;
                    measurementStep.textContent = "Contacto establecido - Circuito cerrado";
                    // Show technical panel for contact explanation
                    document.querySelector('.technical-panel').classList.add('attention');
                    // Close-up view of deformation
                    animateCamera(touchPoint.x + 20, touchPoint.y - 20, 25, touchPoint.x, touchPoint.y, GAP/2);
                    break;
                    
                case 3: // Medici√≥n X
                    updateLayerColors(bottomLayer, 'x');
                    updateLayerColors(topLayer, 'neutral');
                    xVoltage.textContent = `${xVal.toFixed(2)}V`;
                    xAdc.textContent = `ADC: ${xAdcVal} / 4095`;
                    resistanceX.textContent = `${xRes.toFixed(0)} Œ©`;
                    measurementStep.textContent = "Midiendo voltaje en eje X...";
                    // Highlight X measurement
                    document.querySelectorAll('.voltage-card')[0].classList.add('measuring');
                    // Show technical panel for measurement explanation
                    document.querySelector('.technical-panel').classList.add('attention');
                    // Don't update calculator yet - wait for final step
                    // Top-down view to see X gradient
                    animateCamera(0, 0, 80, 0, 0, GAP/2);
                    break;
                    
                case 4: // Medici√≥n Y
                    updateLayerColors(bottomLayer, 'neutral');
                    updateLayerColors(topLayer, 'y');
                    yVoltage.textContent = `${yVal.toFixed(2)}V`;
                    yAdc.textContent = `ADC: ${yAdcVal} / 4095`;
                    resistanceY.textContent = `${yRes.toFixed(0)} Œ©`;
                    measurementStep.textContent = "Midiendo voltaje en eje Y...";
                    // Highlight Y measurement
                    document.querySelectorAll('.voltage-card')[1].classList.add('measuring');
                    // Show technical panel for measurement explanation
                    document.querySelector('.technical-panel').classList.add('attention');
                    // Don't update calculator yet - wait for final step
                    // Rotated view to see Y gradient
                    animateCamera(0, -60, 60, 0, 0, GAP/2);
                    break;
                    
                case 5: // Completo
                    measurementStep.textContent = "Coordenadas calculadas exitosamente";
                    // Show position calculator for final results
                    document.querySelector('.position-calculator').classList.add('attention');
                    updatePositionCalculator(xVal, yVal);
                    // Overview perspective
                    animateCamera(-40, -80, 60, 0, 0, GAP/2);
                    break;
                    
                case 6: // Reiniciar
                    currentStep = -1; // Se incrementar√° a 0
                    break;
            }
            
            showFunMessage(funMessages[currentStep]);
            
            // Resetear posiciones de capa para paso 0
            if (currentStep === 0) {
                topLayer.geometry.attributes.position.array.set(originalPositions);
                topLayer.geometry.attributes.position.needsUpdate = true;
                bottomLayer.geometry.attributes.position.array.set(originalBottomPositions);
                bottomLayer.geometry.attributes.position.needsUpdate = true;
            }
        }

        // Smooth camera animation function
        function animateCamera(targetX, targetY, targetZ, lookAtX = 0, lookAtY = 0, lookAtZ = GAP/2) {
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            const endPos = new THREE.Vector3(targetX, targetY, targetZ);
            const endTarget = new THREE.Vector3(lookAtX, lookAtY, lookAtZ);
            
            let progress = 0;
            const duration = 1000; // 1 second
            const startTime = Date.now();
            
            function animateStep() {
                const currentTime = Date.now();
                progress = Math.min((currentTime - startTime) / duration, 1);
                
                // Smooth easing function
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                camera.position.lerpVectors(startPos, endPos, easeProgress);
                controls.target.lerpVectors(startTarget, endTarget, easeProgress);
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(animateStep);
                }
            }
            
            animateStep();
        }

        function animateFinger() {
            const startPos = { x: finger.position.x, y: finger.position.y, z: finger.position.z };
            const endPos = { x: touchPoint.x, y: touchPoint.y, z: GAP}; // Start position above the layers
            let progress = 0;
            
            function animate() {
                if (!fingerAnimating) return;
                
                progress += 0.015;
                if (progress >= 1) {
                    progress = 1;
                    fingerAnimating = false;
                }
                
                finger.position.x = startPos.x + (endPos.x - startPos.x) * progress;
                finger.position.y = startPos.y + (endPos.y - startPos.y) * progress;
                
                // Only set initial Z position during approach, deformLayer will handle contact positioning
                if (progress <= 0.7) {
                    finger.position.z = startPos.z + (endPos.z - startPos.z) * progress;
                }
                
                if (progress > 0.7) {
                    deformProgress = (progress - 0.7) / 0.3;
                    // deformLayer function will now handle finger.position.z
                }
                
                if (fingerAnimating) {
                    requestAnimationFrame(animate);
                }
            }
            animate();
        }

        function nextStep() {
            currentStep = (currentStep + 1) % totalSteps;
            updateStep();
        }

        function prevStep() {
            currentStep = (currentStep - 1 + totalSteps) % totalSteps;
            updateStep();
        }

        function resetDemo() {
            currentStep = 0;
            updateStep();
        }

        // Event listeners
        canvas.addEventListener('click', (event) => {
            const now = Date.now();
            if (now - lastClickTime < 200) return; // Prevenir doble clic
            lastClickTime = now;
            
            const rect = canvas.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
            
            const intersects = raycaster.intersectObject(topLayer);
            if (intersects.length > 0) {
                touchPoint.x = intersects[0].point.x;
                touchPoint.y = intersects[0].point.y;
                touchPoint.z = intersects[0].point.z;
                
                if (currentStep === 0) {
                    nextStep();
                }
            }
        });

        document.addEventListener('keydown', (event) => {
            switch(event.code) {
                case 'ArrowRight':
                    nextStep();
                    break;
                case 'ArrowLeft':
                    prevStep();
                    break;
                case 'KeyR':
                    resetDemo();
                    break;
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Bucle de animaci√≥n
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            controls.update();
            
            // Make text sprites always face camera
            topLayerLabel.lookAt(camera.position);
            bottomLayerLabel.lookAt(camera.position);
            spacerLabel.lookAt(camera.position);
            
            // Animar part√≠culas
            particlesMesh.rotation.y += 0.001;
            
            // Actualizar deformaci√≥n
            if (deformProgress > 0) {
                deformLayer();
            }
            
            renderer.render(scene, camera);
        }

        // Inicializar
        updateLayerColors(bottomLayer, 'neutral');
        updateLayerColors(topLayer, 'neutral');
        updateStep();
        animate();
        
        // Mensaje de bienvenida
        setTimeout(() => {
            showFunMessage("¬°Bienvenido, joven explorador! üåü");
        }, 1000);
    </script>
</body>
</html>
