<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>¡Explorador de Pantalla Táctil Interactivo!</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Fredoka', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            overflow: hidden;
            user-select: none;
        }
        
        .game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .header {
            text-align: center;
            padding: 8px 15px;
            background: linear-gradient(45deg, #333, #555);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 100;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .university-logo {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            height: 32px;
            width: auto;
            opacity: 0.9;
            transition: opacity 0.3s ease;
            object-fit: cover;
            object-position: center;
        }
        
        .university-logo:hover {
            opacity: 1;
        }
        
        .logo-separator {
            position: absolute;
            left: 50px;
            top: 50%;
            transform: translateY(-50%);
            width: 1px;
            height: 25px;
            background: linear-gradient(to bottom, transparent, #fff, transparent);
            opacity: 0.5;
        }
        
        .faculty-logo {
            position: absolute;
            left: 63px;
            top: 50%;
            transform: translateY(-50%);
            height: 28px;
            width: auto;
            opacity: 0.9;
            transition: opacity 0.3s ease;
            object-fit: cover;
            object-position: center;
        }
        
        .faculty-logo:hover {
            opacity: 1;
        }
        
        .event-title {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.75em;
            font-weight: 600;
            color: #4CAF50;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            text-align: right;
            line-height: 1.2;
        }
        
        .event-year {
            color: #FFD54F;
            font-weight: 700;
        }
        
        .header h1 {
            font-size: 1.2em;
            font-weight: 600;
            color: #fff;
            margin: 0;
        }
        
        .game-area {
            flex: 1;
            position: relative;
            background: linear-gradient(45deg, #1e3c72, #2a5298);
        }
        
        #webgl-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }
        
        .info-panel {
            position: absolute;
            bottom: 130px;
            left: 20px;
            background: rgba(25, 35, 50, 0.85);
            border: 1px solid rgba(80, 120, 160, 0.3);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.25);
            color: #E8F4F8;
            max-width: 300px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            z-index: 1000;
            font-size: 0.9em;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }
        
        .info-panel:hover {
            opacity: 1;
        }
        
        .info-panel.attention {
            opacity: 1;
            border-color: rgba(76, 175, 80, 0.6);
            box-shadow: 0 4px 16px rgba(76, 175, 80, 0.3);
        }
        
        .technical-panel {
            position: absolute;
            bottom: 150px;
            right: 20px;
            background: rgba(25, 35, 50, 0.85);
            border: 1px solid rgba(80, 120, 160, 0.3);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.25);
            color: #E8F4F8;
            max-width: 320px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
            z-index: 1000;
            font-size: 0.85em;
            opacity: 0.4; /* More transparent by default */
            transition: opacity 0.3s ease;
        }
        
        .technical-panel:hover {
            opacity: 1;
        }
        
        .technical-panel.attention {
            opacity: 1;
            border-color: rgba(255, 193, 7, 0.6);
            box-shadow: 0 4px 16px rgba(255, 193, 7, 0.3);
        }
        
        .tech-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #E8F4F8;
            margin-bottom: 12px;
            text-align: center;
            position: relative;
            z-index: 1;
        }
        
        .tech-title::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 2px;
            background: rgba(80, 120, 160, 0.8);
            border-radius: 2px;
        }
        
        .tech-section {
            margin-bottom: 12px;
            padding: 12px;
            background: rgba(40, 60, 80, 0.6);
            border-radius: 8px;
            border: 1px solid rgba(80, 120, 160, 0.3);
            position: relative;
        }
        
        .tech-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: #42A5F5;
            border-radius: 0 2px 2px 0;
        }
        
        .tech-section-title {
            font-size: 1em;
            font-weight: 600;
            color: #90CAF9;
            margin-bottom: 8px;
            padding-left: 8px;
        }
        
        .tech-text {
            font-size: 0.8em;
            line-height: 1.4;
            color: #D0E8FF;
            padding-left: 8px;
        }
        
        .layer-info {
            display: grid;
            grid-template-columns: 1fr;
            gap: 6px;
            margin: 8px 0;
            padding-left: 8px;
        }
        
        .layer-item {
            background: rgba(50, 70, 90, 0.6);
            border-radius: 6px;
            padding: 8px;
            border: 1px solid rgba(80, 120, 160, 0.3);
            position: relative;
            font-size: 0.8em;
            color: #E8F4F8;
        }
        
        .layer-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 3px;
            height: 100%;
            border-radius: 0 2px 2px 0;
        }
        
        .layer-top::before { background: #FF7043; }
        .layer-bottom::before { background: #42A5F5; }
        .layer-spacer::before { background: #FFC107; }
        
        .status-display {
            margin-bottom: 12px;
            padding: 12px;
            background: rgba(40, 60, 80, 0.6);
            border-radius: 8px;
        }
        
        .status-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #90EE90;
            margin-bottom: 6px;
        }
        
        .status-text {
            font-size: 0.95em;
            color: #D0E8FF;
            line-height: 1.3;
        }
        
        .voltage-readings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 12px 0;
        }
        
        .voltage-card {
            background: rgba(50, 70, 90, 0.6);
            border: 1px solid rgba(80, 120, 160, 0.4);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            color: #E8F4F8;
            transition: all 0.3s ease;
        }
        
        .voltage-card.measuring {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
        }
        
        .voltage-label {
            font-size: 0.8em;
            font-weight: 500;
            margin-bottom: 4px;
            opacity: 0.8;
            color: #B8D4EA;
        }
        
        .voltage-value {
            font-size: 1.2em;
            font-weight: 600;
            color: #90EE90;
        }
        
        .voltage-details {
            font-size: 0.75em;
            opacity: 0.7;
            margin-top: 2px;
            color: #A8C8E8;
        }
        
        .measurement-process {
            background: rgba(45, 65, 85, 0.6);
            border: 1px solid rgba(76, 175, 80, 0.4);
            border-radius: 8px;
            padding: 10px;
            margin: 12px 0;
            color: #E8F4F8;
            position: relative;
        }
        
        .measurement-process::before {
            content: '●';
            position: absolute;
            top: 8px;
            right: 12px;
            color: #4CAF50;
            font-size: 1.2em;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .process-title {
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 6px;
            text-align: center;
            color: #90EE90;
        }
        
        .process-step {
            font-size: 0.85em;
            text-align: center;
            margin-bottom: 6px;
            color: #D0E8FF;
        }
        
        .resistance-info {
            font-size: 0.75em;
            text-align: center;
            opacity: 0.8;
            color: #A8C8E8;
        }
        
        .position-calculator {
            background: rgba(45, 65, 85, 0.6);
            border: 1px solid rgba(255, 193, 7, 0.4);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            color: #E8F4F8;
            opacity: 0.4; /* More transparent by default */
            transition: opacity 0.3s ease;
        }
        
        .position-calculator:hover {
            opacity: 1;
        }
        
        .position-calculator.attention {
            opacity: 1;
            border-color: rgba(33, 150, 243, 0.6);
            box-shadow: 0 4px 16px rgba(33, 150, 243, 0.3);
        }
        
        .calculator-title {
            font-size: 0.95em;
            font-weight: 600;
            margin-bottom: 8px;
            text-align: center;
            color: #FFD54F;
        }
        
        .position-formula {
            background: rgba(60, 80, 100, 0.6);
            border-radius: 6px;
            padding: 8px 12px;
            margin: 6px 0;
            font-size: 0.85em;
            font-weight: 500;
            color: #D0E8FF;
            font-family: 'Courier New', monospace;
            text-align: center;
            border: 1px solid rgba(100, 140, 180, 0.3);
        }
        
        .math-formula {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            letter-spacing: 0.5px;
        }
        
        .math-var {
            font-style: italic;
            color: #90CAF9;
            font-weight: 600;
        }
        
        .math-operator {
            color: #FFD54F;
            font-weight: bold;
            margin: 0 2px;
        }
        
        .math-number {
            color: #81C784;
            font-weight: 600;
        }
        
        .math-unit {
            color: #F8BBD9;
            font-size: 0.9em;
        }
        
        .math-result {
            color: #FFB74D; /* Orange for results */
            font-family: "Courier New", monospace;
            font-weight: bold;
            background: rgba(255, 183, 77, 0.1);
            padding: 1px 3px;
            border-radius: 2px;
        }
        
        .math-fraction {
            display: inline-block;
            vertical-align: middle;
            text-align: center;
        }
        
        .math-numerator {
            display: block;
            border-bottom: 1px solid #D0E8FF;
            padding-bottom: 2px;
            margin-bottom: 2px;
        }
        
        .math-denominator {
            display: block;
            padding-top: 2px;
        }
        
        .calculated-position {
            background: rgba(60, 80, 100, 0.8);
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
            text-align: center;
            font-weight: 600;
            font-size: 0.9em;
            color: #FFD54F;
        }
        
        .fun-messages {
            position: absolute;
            bottom: 50px;
            right: 20px;
            background: rgba(255, 107, 107, 0.95);
            border-radius: 20px;
            padding: 15px 20px;
            color: white;
            font-size: 1.2em;
            font-weight: 600;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.5s ease;
            max-width: 300px;
            text-align: center;
            z-index: 50;
        }
        
        .fun-messages.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .controls-hint {
            position: absolute;
            bottom: 50px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            border-radius: 15px;
            padding: 12px 15px;
            color: white;
            font-size: 1em;
            font-weight: 500;
            backdrop-filter: blur(10px);
            z-index: 50;
        }
        
        .key {
            background: #333;
            color: #fff;
            padding: 4px 8px;
            border-radius: 6px;
            font-weight: 600;
            margin: 0 4px;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        
        .bounce {
            animation: bounce 1s;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 8px 32px rgba(255, 107, 107, 0.3); }
            50% { box-shadow: 0 8px 32px rgba(255, 107, 107, 0.8); }
        }
        
        .glowing {
            animation: glow 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <img src="https://comunicacioninstitucional.uabc.mx/wp-content/uploads/2024/03/escudo-actualizado-2022-300ox.png" 
                 alt="Universidad Autónoma de Baja California" 
                 class="university-logo">
            <div class="logo-separator"></div>
            <img src="https://ciencias.ens.uabc.mx/wp-content/themes/THEME-FC/images/object1360936079.png" 
                 alt="Facultad de Ciencias" 
                 class="faculty-logo">
            <h1>Pantalla Táctil Resistiva - Demostración Técnica</h1>
            <div class="event-title">
                XLII SEMANA DE<br>
                CIENCIAS <span class="event-year">2025</span>
            </div>
        </div>
        
        <div class="game-area">
            <canvas id="webgl-canvas"></canvas>
            
            <div class="info-panel">
                <div class="status-display">
                    <div class="status-title" id="status-title">¡Listo para Empezar!</div>
                    <div class="status-text" id="status-text">¡Haz clic en cualquier parte de la pantalla para crear un punto táctil!</div>
                </div>
                
                <div class="voltage-readings">
                    <div class="voltage-card">
                        <div class="voltage-label">Voltaje X (ADC)</div>
                        <div class="voltage-value" id="x-voltage">0.00V</div>
                        <div class="voltage-details" id="x-adc">ADC: 0 / 4095</div>
                    </div>
                    <div class="voltage-card">
                        <div class="voltage-label">Voltaje Y (ADC)</div>
                        <div class="voltage-value" id="y-voltage">0.00V</div>
                        <div class="voltage-details" id="y-adc">ADC: 0 / 4095</div>
                    </div>
                </div>
                
                <div class="measurement-process">
                    <div class="process-title">Estado de Medición</div>
                    <div class="process-step" id="measurement-step">Esperando contacto...</div>
                    <div class="resistance-info">
                        <span>R_x: <span id="resistance-x">∞ Ω</span></span> | 
                        <span>R_y: <span id="resistance-y">∞ Ω</span></span>
                    </div>
                </div>
                
                <div class="position-calculator">
                    <div class="calculator-title">🧮 Calculadora de Posición</div>
                    <div class="position-formula" id="x-formula">
                        X = (Voltaje X ÷ 3.3V) × Ancho
                    </div>
                    <div class="position-formula" id="y-formula">
                        Y = (Voltaje Y ÷ 3.3V) × Alto
                    </div>
                    <div class="calculated-position" id="calculated-position">
                        Posición: Esperando toque...
                    </div>
                </div>
            </div>
            
            <div class="technical-panel">
                <div class="tech-title">🔬 Funcionamiento Técnico</div>
                
                <div class="tech-section">
                    <div class="tech-section-title">Estructura de Capas</div>
                    <div class="layer-info">
                        <div class="layer-item layer-top">
                            <strong>Capa Superior:</strong> Film conductor flexible (ITO)
                        </div>
                        <div class="layer-item layer-spacer">
                            <strong>Separadores:</strong> Puntos aislantes microscópicos
                        </div>
                        <div class="layer-item layer-bottom">
                            <strong>Capa Inferior:</strong> Sustrato conductor rígido
                        </div>
                    </div>
                </div>
                
                <div class="tech-section">
                    <div class="tech-section-title">Principio de Medición</div>
                    <div class="tech-text">
                        <strong>Divisor de Voltaje:</strong><br>
                        • Se aplica voltaje entre extremos<br>
                        • El contacto crea un punto de medición<br>
                        • La posición determina la resistencia<br>
                        • V_medido = V_total × (R_posición / R_total)
                    </div>
                </div>
                
                <div class="tech-section">
                    <div class="tech-section-title">Proceso de Detección</div>
                    <div class="tech-text">
                        <strong>1. Eje X:</strong> Voltaje en bordes izq/der<br>
                        <strong>2. Eje Y:</strong> Voltaje en bordes sup/inf<br>
                        <strong>3. ADC:</strong> Conversión analógica-digital<br>
                        <strong>4. Cálculo:</strong> Coordenadas normalizadas
                    </div>
                </div>
            </div>
            
            <div class="controls-hint">
                <span class="key">←→</span> Pasos | 
                <span class="key">R</span> Reiniciar<br>
                <small style="opacity: 0.8;">🖱️ Arrastra para rotar • Rueda para zoom • Clic derecho para mover</small>
            </div>
            
            <div class="fun-messages" id="fun-messages">
                ¡Excelente trabajo! 🌟
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Estado del juego
        let currentStep = 0;
        let totalSteps = 6;
        let touchPoint = { x: 0, y: 0, z: 0 };
        let lastClickTime = 0;
        
        // Mensajes divertidos para niños
        const funMessages = [
            "¡Increíble! ¡Vamos a explorar! 🚀",
            "¡Mira cómo se mueve el dedo! 👆",
            "¡Mira! ¡La pantalla se dobla! 😮",
            "¡Ahora medimos la dirección X! 📏",
            "¡Es hora de la dirección Y! 📐",
            "¡Encontramos el lugar exacto! 🎯",
            "¡Increíble trabajo, explorador! ⭐"
        ];
        
        const stepTitles = [
            "Sistema Listo",
            "Aproximación del Dedo",
            "Contacto y Deformación", 
            "Medición Eje X (Voltaje)",
            "Medición Eje Y (Voltaje)",
            "Cálculo de Coordenadas",
            "Proceso Completo"
        ];
        
        const stepTexts = [
            "Haz clic en cualquier parte para iniciar el proceso de detección táctil",
            "El dedo se aproxima hacia el punto de contacto seleccionado",
            "La capa superior se deforma al hacer contacto, creando un circuito cerrado",
            "Aplicando voltaje en el eje X y midiendo la resistencia en el punto de contacto",
            "Aplicando voltaje en el eje Y y midiendo la resistencia en el punto de contacto", 
            "Calculando las coordenadas finales basadas en las mediciones de voltaje",
            "Proceso de detección táctil completado. ¡Haz clic para repetir!"
        ];

        // Elementos de la UI
        const canvas = document.getElementById('webgl-canvas');
        const statusTitle = document.getElementById('status-title');
        const statusText = document.getElementById('status-text');
        const xVoltage = document.getElementById('x-voltage');
        const yVoltage = document.getElementById('y-voltage');
        const xAdc = document.getElementById('x-adc');
        const yAdc = document.getElementById('y-adc');
        const measurementStep = document.getElementById('measurement-step');
        const resistanceX = document.getElementById('resistance-x');
        const resistanceY = document.getElementById('resistance-y');
        const funMessagesDiv = document.getElementById('fun-messages');
        const xFormula = document.getElementById('x-formula');
        const yFormula = document.getElementById('y-formula');
        const calculatedPosition = document.getElementById('calculated-position');

        // Configuración de Three.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x001122);
        
        // Constants needed for setup
        const SCREEN_SIZE = 60;
        const SEGMENTS = 30;
        const GAP = 8;
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Add orbit controls for 3D navigation
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 200;
        controls.minDistance = 20;
        controls.target.set(0, 0, GAP/2);
        controls.enablePan = true;
        controls.panSpeed = 0.8;

        // Iluminación optimizada para mostrar el pit sin sombras molestas
        const ambientLight = new THREE.AmbientLight(0x404040, 1.2); // Increased ambient light
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); // Reduced intensity
        directionalLight.position.set(20, 30, 40);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 200;
        directionalLight.shadow.camera.left = -80;
        directionalLight.shadow.camera.right = 80;
        directionalLight.shadow.camera.top = 80;
        directionalLight.shadow.camera.bottom = -80;
        directionalLight.shadow.bias = -0.0001; // Reduced shadow bias
        scene.add(directionalLight);

        // Enhanced spotlight for pit illumination
        const valleySpotlight = new THREE.SpotLight(0x6699ff, 1.2, 80, Math.PI / 4, 0.3, 1.5);
        valleySpotlight.position.set(0, 0, 35);
        valleySpotlight.target.position.set(0, 0, 0);
        valleySpotlight.castShadow = false; // Disable shadows from pit light
        scene.add(valleySpotlight);
        scene.add(valleySpotlight.target);

        // Soft rim lighting for better deformation visibility
        const rimLight = new THREE.DirectionalLight(0x88ccff, 0.3);
        rimLight.position.set(-30, -30, 20);
        rimLight.castShadow = false; // No shadows from rim light
        scene.add(rimLight);

        // Enhanced point light for touch interaction
        const pointLight = new THREE.PointLight(0xffeb3b, 0, 120, 1.8);
        pointLight.castShadow = false; // No shadows from interaction light
        scene.add(pointLight);

        // Crear partículas coloridas para el fondo
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCount = 200;
        const posArray = new Float32Array(particlesCount * 3);
        const colorArray = new Float32Array(particlesCount * 3);

        for(let i = 0; i < particlesCount * 3; i += 3) {
            posArray[i] = (Math.random() - 0.5) * 200;
            posArray[i + 1] = (Math.random() - 0.5) * 200;
            posArray[i + 2] = (Math.random() - 0.5) * 200;
            
            colorArray[i] = Math.random();
            colorArray[i + 1] = Math.random();
            colorArray[i + 2] = Math.random();
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

        const particlesMaterial = new THREE.PointsMaterial({
            size: 2,
            vertexColors: true,
            transparent: true,
            opacity: 0.6
        });

        const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particlesMesh);

        // Crear capas de pantalla táctil (constants already declared above)
        const bottomGeometry = new THREE.PlaneGeometry(SCREEN_SIZE, SCREEN_SIZE, SEGMENTS, SEGMENTS);
        const topGeometry = new THREE.PlaneGeometry(SCREEN_SIZE, SCREEN_SIZE, SEGMENTS, SEGMENTS);

        const bottomMaterial = new THREE.MeshLambertMaterial({ 
            vertexColors: true, 
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.9
        });
        
        const topMaterial = new THREE.MeshLambertMaterial({ 
            vertexColors: true, 
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.7
        });

        const bottomLayer = new THREE.Mesh(bottomGeometry, bottomMaterial);
        const topLayer = new THREE.Mesh(topGeometry, topMaterial);
        
        bottomLayer.position.z = 0;
        topLayer.position.z = GAP;
        bottomLayer.receiveShadow = false; // Disable shadow receiving to avoid distracting shadows
        topLayer.castShadow = true;
        topLayer.receiveShadow = true;
        // Disable bottom layer shadow casting to keep focus on the pit
        bottomLayer.castShadow = false;

        scene.add(bottomLayer);
        scene.add(topLayer);

        // Crear etiquetas para las capas
        function createTextSprite(text, color, size = 16) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = color;
            context.font = `${size}px Arial`;
            context.textAlign = 'center';
            context.fillText(text, 128, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(20, 5, 1);
            
            return sprite;
        }

        // Etiquetas de las capas organizadas
        const topLayerLabel = createTextSprite('Capa Superior (ITO)', '#FF5722', 12);
        topLayerLabel.position.set(0, -40, GAP + 8);
        scene.add(topLayerLabel);

        const bottomLayerLabel = createTextSprite('Capa Inferior (Sustrato)', '#2196F3', 12);
        bottomLayerLabel.position.set(0, -50, -8);
        scene.add(bottomLayerLabel);

        const spacerLabel = createTextSprite('Separadores', '#FFC107', 10);
        spacerLabel.position.set(25, -35, GAP/2);
        scene.add(spacerLabel);

        // Store spacer references for interaction
        const spacers = [];
        
        // Crear puntos de separador visuales (reducidos y organizados)
        const spacerGeometry = new THREE.SphereGeometry(0.8, 8, 8);
        const spacerMaterial = new THREE.MeshBasicMaterial({ color: 0xFFC107 });
        
        // Solo crear algunos separadores estratégicamente ubicados
        for (let i = 0; i < 6; i++) {
            for (let j = 0; j < 6; j++) {
                const spacer = new THREE.Mesh(spacerGeometry, spacerMaterial);
                const spacerPos = {
                    x: (i - 2.5) * 12,
                    y: (j - 2.5) * 12,
                    z: GAP/2
                };
                spacer.position.set(spacerPos.x, spacerPos.y, spacerPos.z);
                spacer.userData.originalPosition = spacerPos;
                spacer.userData.originalScale = 1;
                scene.add(spacer);
                spacers.push(spacer);
            }
        }

        // Guardar posiciones originales
        const originalPositions = topLayer.geometry.attributes.position.array.slice();
        const originalBottomPositions = bottomLayer.geometry.attributes.position.array.slice();

        // Crear dedo
        const fingerGeometry = new THREE.CylinderGeometry(4, 3.5, 20, 16);
        const fingerMaterial = new THREE.MeshLambertMaterial({ color: 0xffb380 });
        const finger = new THREE.Mesh(fingerGeometry, fingerMaterial);
        finger.rotation.x = Math.PI / 2;
        finger.castShadow = true;
        finger.position.set(0, 0, 50);
        scene.add(finger);

        // Configuración de cámara
        camera.position.set(0, -100, 80);
        camera.lookAt(0, 0, GAP/2);

        // Estado de animación
        let deformProgress = 0;
        let fingerAnimating = false;

        function updateLayerColors(layer, type) {
            const positions = layer.geometry.attributes.position;
            const colors = new Float32Array(positions.count * 3);
            
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                let r, g, b;

                if (type === 'x') {
                    const intensity = (x + SCREEN_SIZE / 2) / SCREEN_SIZE;
                    r = intensity * 0.8 + 0.2;
                    g = 0.3;
                    b = (1 - intensity) * 0.8 + 0.2;
                } else if (type === 'y') {
                    const intensity = (y + SCREEN_SIZE / 2) / SCREEN_SIZE;
                    r = (1 - intensity) * 0.8 + 0.2;
                    g = intensity * 0.8 + 0.2;
                    b = 0.8;
                } else {
                    r = 0.4;
                    g = 0.8;
                    b = 1.0;
                }

                colors[i * 3] = r;
                colors[i * 3 + 1] = g;
                colors[i * 3 + 2] = b;
            }

            layer.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        }

        function deformLayer() {
            const topPositions = topLayer.geometry.attributes.position;
            const bottomPositions = bottomLayer.geometry.attributes.position;
            const sigma = SCREEN_SIZE / 6; // Tighter deformation area
            const maxDeform = GAP * 0.95; // Deformation almost reaches bottom layer
            
            let maxDeformationAtTouch = 0; // Track maximum deformation at touch point
            
            // Deform top layer
            for (let i = 0; i < topPositions.count; i++) {
                const x = topPositions.getX(i);
                const y = topPositions.getY(i);
                const originalZ = originalPositions[i * 3 + 2];
                
                const distance = Math.sqrt(
                    Math.pow(x - touchPoint.x, 2) + 
                    Math.pow(y - touchPoint.y, 2)
                );
                
                // More realistic gaussian falloff with material tension
                const influence = Math.exp(-(distance * distance) / (2 * sigma * sigma));
                
                // Add material resistance - deformation decreases with distance
                const materialTension = 1 - (distance / (SCREEN_SIZE * 0.4));
                const adjustedInfluence = influence * Math.max(0, materialTension);
                
                // More realistic deformation curve
                const deformation = adjustedInfluence * maxDeform * Math.pow(deformProgress, 1.5);
                
                // Track maximum deformation at the touch point for finger positioning
                if (distance < 2) { // Very close to touch point
                    maxDeformationAtTouch = Math.max(maxDeformationAtTouch, deformation);
                }
                
                topPositions.setZ(i, originalZ - deformation);
            }
            topPositions.needsUpdate = true;
            
            // Deform bottom layer slightly when top layer approaches (contact effect)
            if (deformProgress > 0.5) {
                for (let i = 0; i < bottomPositions.count; i++) {
                    const x = bottomPositions.getX(i);
                    const y = bottomPositions.getY(i);
                    
                    const distance = Math.sqrt(
                        Math.pow(x - touchPoint.x, 2) + 
                        Math.pow(y - touchPoint.y, 2)
                    );
                    
                    const influence = Math.exp(-(distance * distance) / (2 * sigma * sigma));
                    
                    // Bottom layer deforms upward slightly when contacted
                    const bottomDeformation = influence * (GAP * 0.15) * Math.pow((deformProgress - 0.5) * 2, 2);
                    
                    bottomPositions.setZ(i, bottomDeformation);
                }
                bottomPositions.needsUpdate = true;
            } else {
                // Reset bottom layer when not in contact
                for (let i = 0; i < bottomPositions.count; i++) {
                    bottomPositions.setZ(i, 0);
                }
                bottomPositions.needsUpdate = true;
            }
            
            // Update finger position to follow the deformation but stay above surface
            if (deformProgress > 0) {
                // Keep finger above the deformed surface by a safe margin
                const fingerTargetZ = GAP + 4 - (maxDeformationAtTouch * 0.7);
                finger.position.z = Math.max(fingerTargetZ, GAP + 5);
            }
            
            // Interact with spacers - compress them when deformation reaches them
            spacers.forEach(spacer => {
                const distance = Math.sqrt(
                    Math.pow(spacer.userData.originalPosition.x - touchPoint.x, 2) + 
                    Math.pow(spacer.userData.originalPosition.y - touchPoint.y, 2)
                );
                
                const spacerInfluence = Math.exp(-(distance * distance) / (2 * sigma * sigma));
                
                if (spacerInfluence > 0.1 && deformProgress > 0.3) {
                    // Compress spacer - make it compress more realistically
                    const compression = spacerInfluence * deformProgress * 0.8;
                    spacer.scale.z = spacer.userData.originalScale * (1 - compression);
                    
                    // Position spacer to be compressed between layers
                    const compressedGap = GAP * (1 - compression * 0.7);
                    spacer.position.z = compressedGap / 2;
                    
                    // Change color to show compression stress
                    const stress = compression;
                    spacer.material.color.setRGB(
                        0.8 + stress * 0.2,
                        0.8 - stress * 0.4,
                        0.2 + stress * 0.3
                    );
                } else {
                    // Reset to original state
                    spacer.scale.z = spacer.userData.originalScale;
                    spacer.position.z = spacer.userData.originalPosition.z;
                    spacer.material.color.setHex(0xFFC107);
                }
            });
        }

        function showFunMessage(message) {
            funMessagesDiv.textContent = message;
            funMessagesDiv.classList.add('show');
            funMessagesDiv.classList.add('bounce');
            
            setTimeout(() => {
                funMessagesDiv.classList.remove('bounce');
            }, 1000);
            
            setTimeout(() => {
                funMessagesDiv.classList.remove('show');
            }, 3000);
        }

        function updatePositionCalculator(xVal, yVal) {
            // Calcular posición basada en voltajes en el rango (0,0) a (100,100)
            const maxVoltage = 3.3;
            
            // Convertir voltajes a coordenadas 0-100
            const calculatedX = (xVal / maxVoltage) * 100;
            const calculatedY = (yVal / maxVoltage) * 100;
            
            // Actualizar fórmulas con valores reales y matemática LaTeX-style
            xFormula.innerHTML = `
                <span class="math-var">X</span> <span class="math-operator">=</span> 
                <span class="math-operator">(</span><span class="math-number">${xVal.toFixed(2)}</span><span class="math-unit">V</span> 
                <span class="math-operator">÷</span> <span class="math-number">3.3</span><span class="math-unit">V</span><span class="math-operator">)</span> 
                <span class="math-operator">×</span> <span class="math-number">100</span> 
                <span class="math-operator">=</span> <span class="math-result">${calculatedX.toFixed(1)}</span>
            `;
            
            yFormula.innerHTML = `
                <span class="math-var">Y</span> <span class="math-operator">=</span> 
                <span class="math-operator">(</span><span class="math-number">${yVal.toFixed(2)}</span><span class="math-unit">V</span> 
                <span class="math-operator">÷</span> <span class="math-number">3.3</span><span class="math-unit">V</span><span class="math-operator">)</span> 
                <span class="math-operator">×</span> <span class="math-number">100</span> 
                <span class="math-operator">=</span> <span class="math-result">${calculatedY.toFixed(1)}</span>
            `;
            
            // Mostrar posición calculada con formato matemático
            calculatedPosition.innerHTML = `
                <strong>Posición:</strong> 
                <span class="math-operator">(</span><span class="math-result">${calculatedX.toFixed(1)}</span>, 
                <span class="math-result">${calculatedY.toFixed(1)}</span><span class="math-operator">)</span>
            `;
            
            // Añadir efectos visuales
            if (xVal > 0 && yVal > 0) {
                calculatedPosition.classList.add('pulse');
                setTimeout(() => {
                    calculatedPosition.classList.remove('pulse');
                }, 2000);
            }
        }

        function updateStep() {
            statusTitle.textContent = stepTitles[currentStep];
            statusText.textContent = stepTexts[currentStep];
            
            // Reset attention states instead of hiding panels
            document.querySelectorAll('.info-panel, .technical-panel, .position-calculator').forEach(panel => {
                panel.classList.remove('attention');
            });
            document.querySelectorAll('.voltage-card').forEach(card => {
                card.classList.remove('measuring');
            });
            
            // Resetear estados
            pointLight.intensity = 0;
            deformProgress = 0;
            fingerAnimating = false;
            
            // Actualizar displays de voltaje
            const xVal = ((touchPoint.x + SCREEN_SIZE/2) / SCREEN_SIZE) * 3.3;
            const yVal = ((touchPoint.y + SCREEN_SIZE/2) / SCREEN_SIZE) * 3.3;
            const xAdcVal = Math.round((xVal / 3.3) * 4095);
            const yAdcVal = Math.round((yVal / 3.3) * 4095);
            const xRes = (xVal / 3.3) * 1000; // Resistencia simulada en Ω
            const yRes = (yVal / 3.3) * 1000;

            switch(currentStep) {
                case 0: // Listo
                    finger.position.set(0, 0, 50);
                    updateLayerColors(bottomLayer, 'neutral');
                    updateLayerColors(topLayer, 'neutral');
                    xVoltage.textContent = "0.00V";
                    yVoltage.textContent = "0.00V";
                    xAdc.textContent = "ADC: 0 / 4095";
                    yAdc.textContent = "ADC: 0 / 4095";
                    measurementStep.textContent = "Esperando contacto...";
                    resistanceX.textContent = "∞ Ω";
                    resistanceY.textContent = "∞ Ω";
                    calculatedPosition.textContent = "Posición: Esperando toque...";
                    xFormula.innerHTML = `
                        <span class="math-var">X</span> <span class="math-operator">=</span> 
                        <span class="math-operator">(</span><span class="math-var">Voltaje X</span> 
                        <span class="math-operator">÷</span> <span class="math-number">3.3</span><span class="math-unit">V</span><span class="math-operator">)</span> 
                        <span class="math-operator">×</span> <span class="math-number">100</span>
                    `;
                    yFormula.innerHTML = `
                        <span class="math-var">Y</span> <span class="math-operator">=</span> 
                        <span class="math-operator">(</span><span class="math-var">Voltaje Y</span> 
                        <span class="math-operator">÷</span> <span class="math-number">3.3</span><span class="math-unit">V</span><span class="math-operator">)</span> 
                        <span class="math-operator">×</span> <span class="math-number">100</span>
                    `;
                    // Reset to default view
                    animateCamera(0, -100, 80, 0, 0, GAP/2);
                    break;
                    
                case 1: // Moviendo dedo
                    fingerAnimating = true;
                    measurementStep.textContent = "Aproximando al punto de contacto...";
                    animateFinger();
                    // Side view to see finger approach
                    animateCamera(60, -40, 40, touchPoint.x, touchPoint.y, GAP/2);
                    break;
                    
                case 2: // Contacto
                    deformProgress = 1;
                    pointLight.position.set(touchPoint.x, touchPoint.y, touchPoint.z);
                    pointLight.intensity = 2;
                    measurementStep.textContent = "Contacto establecido - Circuito cerrado";
                    // Show technical panel for contact explanation
                    document.querySelector('.technical-panel').classList.add('attention');
                    // Close-up view of deformation
                    animateCamera(touchPoint.x + 20, touchPoint.y - 20, 25, touchPoint.x, touchPoint.y, GAP/2);
                    break;
                    
                case 3: // Medición X
                    updateLayerColors(bottomLayer, 'x');
                    updateLayerColors(topLayer, 'neutral');
                    xVoltage.textContent = `${xVal.toFixed(2)}V`;
                    xAdc.textContent = `ADC: ${xAdcVal} / 4095`;
                    resistanceX.textContent = `${xRes.toFixed(0)} Ω`;
                    measurementStep.textContent = "Midiendo voltaje en eje X...";
                    // Highlight X measurement
                    document.querySelectorAll('.voltage-card')[0].classList.add('measuring');
                    // Show technical panel for measurement explanation
                    document.querySelector('.technical-panel').classList.add('attention');
                    // Don't update calculator yet - wait for final step
                    // Top-down view to see X gradient
                    animateCamera(0, 0, 80, 0, 0, GAP/2);
                    break;
                    
                case 4: // Medición Y
                    updateLayerColors(bottomLayer, 'neutral');
                    updateLayerColors(topLayer, 'y');
                    yVoltage.textContent = `${yVal.toFixed(2)}V`;
                    yAdc.textContent = `ADC: ${yAdcVal} / 4095`;
                    resistanceY.textContent = `${yRes.toFixed(0)} Ω`;
                    measurementStep.textContent = "Midiendo voltaje en eje Y...";
                    // Highlight Y measurement
                    document.querySelectorAll('.voltage-card')[1].classList.add('measuring');
                    // Show technical panel for measurement explanation
                    document.querySelector('.technical-panel').classList.add('attention');
                    // Don't update calculator yet - wait for final step
                    // Rotated view to see Y gradient
                    animateCamera(0, -60, 60, 0, 0, GAP/2);
                    break;
                    
                case 5: // Completo
                    measurementStep.textContent = "Coordenadas calculadas exitosamente";
                    // Show position calculator for final results
                    document.querySelector('.position-calculator').classList.add('attention');
                    updatePositionCalculator(xVal, yVal);
                    // Overview perspective
                    animateCamera(-40, -80, 60, 0, 0, GAP/2);
                    break;
                    
                case 6: // Reiniciar
                    currentStep = -1; // Se incrementará a 0
                    break;
            }
            
            showFunMessage(funMessages[currentStep]);
            
            // Resetear posiciones de capa para paso 0
            if (currentStep === 0) {
                topLayer.geometry.attributes.position.array.set(originalPositions);
                topLayer.geometry.attributes.position.needsUpdate = true;
                bottomLayer.geometry.attributes.position.array.set(originalBottomPositions);
                bottomLayer.geometry.attributes.position.needsUpdate = true;
            }
        }

        // Smooth camera animation function
        function animateCamera(targetX, targetY, targetZ, lookAtX = 0, lookAtY = 0, lookAtZ = GAP/2) {
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            const endPos = new THREE.Vector3(targetX, targetY, targetZ);
            const endTarget = new THREE.Vector3(lookAtX, lookAtY, lookAtZ);
            
            let progress = 0;
            const duration = 1000; // 1 second
            const startTime = Date.now();
            
            function animateStep() {
                const currentTime = Date.now();
                progress = Math.min((currentTime - startTime) / duration, 1);
                
                // Smooth easing function
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                camera.position.lerpVectors(startPos, endPos, easeProgress);
                controls.target.lerpVectors(startTarget, endTarget, easeProgress);
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(animateStep);
                }
            }
            
            animateStep();
        }

        function animateFinger() {
            const startPos = { x: finger.position.x, y: finger.position.y, z: finger.position.z };
            const endPos = { x: touchPoint.x, y: touchPoint.y, z: GAP}; // Start position above the layers
            let progress = 0;
            
            function animate() {
                if (!fingerAnimating) return;
                
                progress += 0.015;
                if (progress >= 1) {
                    progress = 1;
                    fingerAnimating = false;
                }
                
                finger.position.x = startPos.x + (endPos.x - startPos.x) * progress;
                finger.position.y = startPos.y + (endPos.y - startPos.y) * progress;
                
                // Only set initial Z position during approach, deformLayer will handle contact positioning
                if (progress <= 0.7) {
                    finger.position.z = startPos.z + (endPos.z - startPos.z) * progress;
                }
                
                if (progress > 0.7) {
                    deformProgress = (progress - 0.7) / 0.3;
                    // deformLayer function will now handle finger.position.z
                }
                
                if (fingerAnimating) {
                    requestAnimationFrame(animate);
                }
            }
            animate();
        }

        function nextStep() {
            currentStep = (currentStep + 1) % totalSteps;
            updateStep();
        }

        function prevStep() {
            currentStep = (currentStep - 1 + totalSteps) % totalSteps;
            updateStep();
        }

        function resetDemo() {
            currentStep = 0;
            updateStep();
        }

        // Event listeners
        canvas.addEventListener('click', (event) => {
            const now = Date.now();
            if (now - lastClickTime < 200) return; // Prevenir doble clic
            lastClickTime = now;
            
            const rect = canvas.getBoundingClientRect();
            const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
            
            const intersects = raycaster.intersectObject(topLayer);
            if (intersects.length > 0) {
                touchPoint.x = intersects[0].point.x;
                touchPoint.y = intersects[0].point.y;
                touchPoint.z = intersects[0].point.z;
                
                if (currentStep === 0) {
                    nextStep();
                }
            }
        });

        document.addEventListener('keydown', (event) => {
            switch(event.code) {
                case 'ArrowRight':
                    nextStep();
                    break;
                case 'ArrowLeft':
                    prevStep();
                    break;
                case 'KeyR':
                    resetDemo();
                    break;
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Bucle de animación
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            controls.update();
            
            // Make text sprites always face camera
            topLayerLabel.lookAt(camera.position);
            bottomLayerLabel.lookAt(camera.position);
            spacerLabel.lookAt(camera.position);
            
            // Animar partículas
            particlesMesh.rotation.y += 0.001;
            
            // Actualizar deformación
            if (deformProgress > 0) {
                deformLayer();
            }
            
            renderer.render(scene, camera);
        }

        // Inicializar
        updateLayerColors(bottomLayer, 'neutral');
        updateLayerColors(topLayer, 'neutral');
        updateStep();
        animate();
        
        // Mensaje de bienvenida
        setTimeout(() => {
            showFunMessage("¡Bienvenido, joven explorador! 🌟");
        }, 1000);
    </script>
</body>
</html>
